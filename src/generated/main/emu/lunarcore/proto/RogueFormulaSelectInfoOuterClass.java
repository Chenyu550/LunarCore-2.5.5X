// Code generated by protocol buffer compiler. Do not edit!
package emu.lunarcore.proto;

import java.io.IOException;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.RepeatedInt;

public final class RogueFormulaSelectInfoOuterClass {
  /**
   * Protobuf type {@code RogueFormulaSelectInfo}
   */
  public static final class RogueFormulaSelectInfo extends ProtoMessage<RogueFormulaSelectInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 roll_formula_max_count = 2;</code>
     */
    private int rollFormulaMaxCount;

    /**
     * <code>optional uint32 roll_formula_free_count = 4;</code>
     */
    private int rollFormulaFreeCount;

    /**
     * <code>optional uint32 roll_formula_count = 6;</code>
     */
    private int rollFormulaCount;

    /**
     * <code>optional uint32 hint_id = 11;</code>
     */
    private int hintId;

    /**
     * <code>optional bool can_roll = 15;</code>
     */
    private boolean canRoll;

    /**
     * <code>optional .ItemCostList roll_formula_cost_data = 9;</code>
     */
    private final ItemCostListOuterClass.ItemCostList rollFormulaCostData = ItemCostListOuterClass.ItemCostList.newInstance();

    /**
     * <code>repeated uint32 select_formula_id_list = 5;</code>
     */
    private final RepeatedInt selectFormulaIdList = RepeatedInt.newEmptyInstance();

    /**
     * <code>repeated uint32 handbook_unlock_formula_id_list = 13;</code>
     */
    private final RepeatedInt handbookUnlockFormulaIdList = RepeatedInt.newEmptyInstance();

    private RogueFormulaSelectInfo() {
    }

    /**
     * @return a new empty instance of {@code RogueFormulaSelectInfo}
     */
    public static RogueFormulaSelectInfo newInstance() {
      return new RogueFormulaSelectInfo();
    }

    /**
     * <code>optional uint32 roll_formula_max_count = 2;</code>
     * @return whether the rollFormulaMaxCount field is set
     */
    public boolean hasRollFormulaMaxCount() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 roll_formula_max_count = 2;</code>
     * @return this
     */
    public RogueFormulaSelectInfo clearRollFormulaMaxCount() {
      bitField0_ &= ~0x00000001;
      rollFormulaMaxCount = 0;
      return this;
    }

    /**
     * <code>optional uint32 roll_formula_max_count = 2;</code>
     * @return the rollFormulaMaxCount
     */
    public int getRollFormulaMaxCount() {
      return rollFormulaMaxCount;
    }

    /**
     * <code>optional uint32 roll_formula_max_count = 2;</code>
     * @param value the rollFormulaMaxCount to set
     * @return this
     */
    public RogueFormulaSelectInfo setRollFormulaMaxCount(final int value) {
      bitField0_ |= 0x00000001;
      rollFormulaMaxCount = value;
      return this;
    }

    /**
     * <code>optional uint32 roll_formula_free_count = 4;</code>
     * @return whether the rollFormulaFreeCount field is set
     */
    public boolean hasRollFormulaFreeCount() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 roll_formula_free_count = 4;</code>
     * @return this
     */
    public RogueFormulaSelectInfo clearRollFormulaFreeCount() {
      bitField0_ &= ~0x00000002;
      rollFormulaFreeCount = 0;
      return this;
    }

    /**
     * <code>optional uint32 roll_formula_free_count = 4;</code>
     * @return the rollFormulaFreeCount
     */
    public int getRollFormulaFreeCount() {
      return rollFormulaFreeCount;
    }

    /**
     * <code>optional uint32 roll_formula_free_count = 4;</code>
     * @param value the rollFormulaFreeCount to set
     * @return this
     */
    public RogueFormulaSelectInfo setRollFormulaFreeCount(final int value) {
      bitField0_ |= 0x00000002;
      rollFormulaFreeCount = value;
      return this;
    }

    /**
     * <code>optional uint32 roll_formula_count = 6;</code>
     * @return whether the rollFormulaCount field is set
     */
    public boolean hasRollFormulaCount() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 roll_formula_count = 6;</code>
     * @return this
     */
    public RogueFormulaSelectInfo clearRollFormulaCount() {
      bitField0_ &= ~0x00000004;
      rollFormulaCount = 0;
      return this;
    }

    /**
     * <code>optional uint32 roll_formula_count = 6;</code>
     * @return the rollFormulaCount
     */
    public int getRollFormulaCount() {
      return rollFormulaCount;
    }

    /**
     * <code>optional uint32 roll_formula_count = 6;</code>
     * @param value the rollFormulaCount to set
     * @return this
     */
    public RogueFormulaSelectInfo setRollFormulaCount(final int value) {
      bitField0_ |= 0x00000004;
      rollFormulaCount = value;
      return this;
    }

    /**
     * <code>optional uint32 hint_id = 11;</code>
     * @return whether the hintId field is set
     */
    public boolean hasHintId() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 hint_id = 11;</code>
     * @return this
     */
    public RogueFormulaSelectInfo clearHintId() {
      bitField0_ &= ~0x00000008;
      hintId = 0;
      return this;
    }

    /**
     * <code>optional uint32 hint_id = 11;</code>
     * @return the hintId
     */
    public int getHintId() {
      return hintId;
    }

    /**
     * <code>optional uint32 hint_id = 11;</code>
     * @param value the hintId to set
     * @return this
     */
    public RogueFormulaSelectInfo setHintId(final int value) {
      bitField0_ |= 0x00000008;
      hintId = value;
      return this;
    }

    /**
     * <code>optional bool can_roll = 15;</code>
     * @return whether the canRoll field is set
     */
    public boolean hasCanRoll() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional bool can_roll = 15;</code>
     * @return this
     */
    public RogueFormulaSelectInfo clearCanRoll() {
      bitField0_ &= ~0x00000010;
      canRoll = false;
      return this;
    }

    /**
     * <code>optional bool can_roll = 15;</code>
     * @return the canRoll
     */
    public boolean getCanRoll() {
      return canRoll;
    }

    /**
     * <code>optional bool can_roll = 15;</code>
     * @param value the canRoll to set
     * @return this
     */
    public RogueFormulaSelectInfo setCanRoll(final boolean value) {
      bitField0_ |= 0x00000010;
      canRoll = value;
      return this;
    }

    /**
     * <code>optional .ItemCostList roll_formula_cost_data = 9;</code>
     * @return whether the rollFormulaCostData field is set
     */
    public boolean hasRollFormulaCostData() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional .ItemCostList roll_formula_cost_data = 9;</code>
     * @return this
     */
    public RogueFormulaSelectInfo clearRollFormulaCostData() {
      bitField0_ &= ~0x00000020;
      rollFormulaCostData.clear();
      return this;
    }

    /**
     * <code>optional .ItemCostList roll_formula_cost_data = 9;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRollFormulaCostData()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ItemCostListOuterClass.ItemCostList getRollFormulaCostData() {
      return rollFormulaCostData;
    }

    /**
     * <code>optional .ItemCostList roll_formula_cost_data = 9;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ItemCostListOuterClass.ItemCostList getMutableRollFormulaCostData() {
      bitField0_ |= 0x00000020;
      return rollFormulaCostData;
    }

    /**
     * <code>optional .ItemCostList roll_formula_cost_data = 9;</code>
     * @param value the rollFormulaCostData to set
     * @return this
     */
    public RogueFormulaSelectInfo setRollFormulaCostData(
        final ItemCostListOuterClass.ItemCostList value) {
      bitField0_ |= 0x00000020;
      rollFormulaCostData.copyFrom(value);
      return this;
    }

    /**
     * <code>repeated uint32 select_formula_id_list = 5;</code>
     * @return whether the selectFormulaIdList field is set
     */
    public boolean hasSelectFormulaIdList() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>repeated uint32 select_formula_id_list = 5;</code>
     * @return this
     */
    public RogueFormulaSelectInfo clearSelectFormulaIdList() {
      bitField0_ &= ~0x00000040;
      selectFormulaIdList.clear();
      return this;
    }

    /**
     * <code>repeated uint32 select_formula_id_list = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableSelectFormulaIdList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getSelectFormulaIdList() {
      return selectFormulaIdList;
    }

    /**
     * <code>repeated uint32 select_formula_id_list = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableSelectFormulaIdList() {
      bitField0_ |= 0x00000040;
      return selectFormulaIdList;
    }

    /**
     * <code>repeated uint32 select_formula_id_list = 5;</code>
     * @param value the selectFormulaIdList to add
     * @return this
     */
    public RogueFormulaSelectInfo addSelectFormulaIdList(final int value) {
      bitField0_ |= 0x00000040;
      selectFormulaIdList.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 select_formula_id_list = 5;</code>
     * @param values the selectFormulaIdList to add
     * @return this
     */
    public RogueFormulaSelectInfo addAllSelectFormulaIdList(final int... values) {
      bitField0_ |= 0x00000040;
      selectFormulaIdList.addAll(values);
      return this;
    }

    /**
     * <code>repeated uint32 handbook_unlock_formula_id_list = 13;</code>
     * @return whether the handbookUnlockFormulaIdList field is set
     */
    public boolean hasHandbookUnlockFormulaIdList() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>repeated uint32 handbook_unlock_formula_id_list = 13;</code>
     * @return this
     */
    public RogueFormulaSelectInfo clearHandbookUnlockFormulaIdList() {
      bitField0_ &= ~0x00000080;
      handbookUnlockFormulaIdList.clear();
      return this;
    }

    /**
     * <code>repeated uint32 handbook_unlock_formula_id_list = 13;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableHandbookUnlockFormulaIdList()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getHandbookUnlockFormulaIdList() {
      return handbookUnlockFormulaIdList;
    }

    /**
     * <code>repeated uint32 handbook_unlock_formula_id_list = 13;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableHandbookUnlockFormulaIdList() {
      bitField0_ |= 0x00000080;
      return handbookUnlockFormulaIdList;
    }

    /**
     * <code>repeated uint32 handbook_unlock_formula_id_list = 13;</code>
     * @param value the handbookUnlockFormulaIdList to add
     * @return this
     */
    public RogueFormulaSelectInfo addHandbookUnlockFormulaIdList(final int value) {
      bitField0_ |= 0x00000080;
      handbookUnlockFormulaIdList.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 handbook_unlock_formula_id_list = 13;</code>
     * @param values the handbookUnlockFormulaIdList to add
     * @return this
     */
    public RogueFormulaSelectInfo addAllHandbookUnlockFormulaIdList(final int... values) {
      bitField0_ |= 0x00000080;
      handbookUnlockFormulaIdList.addAll(values);
      return this;
    }

    @Override
    public RogueFormulaSelectInfo copyFrom(final RogueFormulaSelectInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        rollFormulaMaxCount = other.rollFormulaMaxCount;
        rollFormulaFreeCount = other.rollFormulaFreeCount;
        rollFormulaCount = other.rollFormulaCount;
        hintId = other.hintId;
        canRoll = other.canRoll;
        rollFormulaCostData.copyFrom(other.rollFormulaCostData);
        selectFormulaIdList.copyFrom(other.selectFormulaIdList);
        handbookUnlockFormulaIdList.copyFrom(other.handbookUnlockFormulaIdList);
      }
      return this;
    }

    @Override
    public RogueFormulaSelectInfo mergeFrom(final RogueFormulaSelectInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasRollFormulaMaxCount()) {
        setRollFormulaMaxCount(other.rollFormulaMaxCount);
      }
      if (other.hasRollFormulaFreeCount()) {
        setRollFormulaFreeCount(other.rollFormulaFreeCount);
      }
      if (other.hasRollFormulaCount()) {
        setRollFormulaCount(other.rollFormulaCount);
      }
      if (other.hasHintId()) {
        setHintId(other.hintId);
      }
      if (other.hasCanRoll()) {
        setCanRoll(other.canRoll);
      }
      if (other.hasRollFormulaCostData()) {
        getMutableRollFormulaCostData().mergeFrom(other.rollFormulaCostData);
      }
      if (other.hasSelectFormulaIdList()) {
        getMutableSelectFormulaIdList().addAll(other.selectFormulaIdList);
      }
      if (other.hasHandbookUnlockFormulaIdList()) {
        getMutableHandbookUnlockFormulaIdList().addAll(other.handbookUnlockFormulaIdList);
      }
      return this;
    }

    @Override
    public RogueFormulaSelectInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      rollFormulaMaxCount = 0;
      rollFormulaFreeCount = 0;
      rollFormulaCount = 0;
      hintId = 0;
      canRoll = false;
      rollFormulaCostData.clear();
      selectFormulaIdList.clear();
      handbookUnlockFormulaIdList.clear();
      return this;
    }

    @Override
    public RogueFormulaSelectInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      rollFormulaCostData.clearQuick();
      selectFormulaIdList.clear();
      handbookUnlockFormulaIdList.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RogueFormulaSelectInfo)) {
        return false;
      }
      RogueFormulaSelectInfo other = (RogueFormulaSelectInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasRollFormulaMaxCount() || rollFormulaMaxCount == other.rollFormulaMaxCount)
        && (!hasRollFormulaFreeCount() || rollFormulaFreeCount == other.rollFormulaFreeCount)
        && (!hasRollFormulaCount() || rollFormulaCount == other.rollFormulaCount)
        && (!hasHintId() || hintId == other.hintId)
        && (!hasCanRoll() || canRoll == other.canRoll)
        && (!hasRollFormulaCostData() || rollFormulaCostData.equals(other.rollFormulaCostData))
        && (!hasSelectFormulaIdList() || selectFormulaIdList.equals(other.selectFormulaIdList))
        && (!hasHandbookUnlockFormulaIdList() || handbookUnlockFormulaIdList.equals(other.handbookUnlockFormulaIdList));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(rollFormulaMaxCount);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(rollFormulaFreeCount);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 48);
        output.writeUInt32NoTag(rollFormulaCount);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 88);
        output.writeUInt32NoTag(hintId);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 120);
        output.writeBoolNoTag(canRoll);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 74);
        output.writeMessageNoTag(rollFormulaCostData);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        for (int i = 0; i < selectFormulaIdList.length(); i++) {
          output.writeRawByte((byte) 40);
          output.writeUInt32NoTag(selectFormulaIdList.array()[i]);
        }
      }
      if ((bitField0_ & 0x00000080) != 0) {
        for (int i = 0; i < handbookUnlockFormulaIdList.length(); i++) {
          output.writeRawByte((byte) 104);
          output.writeUInt32NoTag(handbookUnlockFormulaIdList.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(rollFormulaMaxCount);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(rollFormulaFreeCount);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(rollFormulaCount);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(hintId);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(rollFormulaCostData);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += (1 * selectFormulaIdList.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(selectFormulaIdList);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += (1 * handbookUnlockFormulaIdList.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(handbookUnlockFormulaIdList);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RogueFormulaSelectInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 16: {
            // rollFormulaMaxCount
            rollFormulaMaxCount = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // rollFormulaFreeCount
            rollFormulaFreeCount = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // rollFormulaCount
            rollFormulaCount = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 88) {
              break;
            }
          }
          case 88: {
            // hintId
            hintId = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 120) {
              break;
            }
          }
          case 120: {
            // canRoll
            canRoll = input.readBool();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 74) {
              break;
            }
          }
          case 74: {
            // rollFormulaCostData
            input.readMessage(rollFormulaCostData);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // selectFormulaIdList [packed=true]
            input.readPackedUInt32(selectFormulaIdList, tag);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 106) {
              break;
            }
          }
          case 106: {
            // handbookUnlockFormulaIdList [packed=true]
            input.readPackedUInt32(handbookUnlockFormulaIdList, tag);
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 40: {
            // selectFormulaIdList [packed=false]
            tag = input.readRepeatedUInt32(selectFormulaIdList, tag);
            bitField0_ |= 0x00000040;
            break;
          }
          case 104: {
            // handbookUnlockFormulaIdList [packed=false]
            tag = input.readRepeatedUInt32(handbookUnlockFormulaIdList, tag);
            bitField0_ |= 0x00000080;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.rollFormulaMaxCount, rollFormulaMaxCount);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.rollFormulaFreeCount, rollFormulaFreeCount);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.rollFormulaCount, rollFormulaCount);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.hintId, hintId);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeBool(FieldNames.canRoll, canRoll);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeMessage(FieldNames.rollFormulaCostData, rollFormulaCostData);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRepeatedUInt32(FieldNames.selectFormulaIdList, selectFormulaIdList);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRepeatedUInt32(FieldNames.handbookUnlockFormulaIdList, handbookUnlockFormulaIdList);
      }
      output.endObject();
    }

    @Override
    public RogueFormulaSelectInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1686763348:
          case 823994265: {
            if (input.isAtField(FieldNames.rollFormulaMaxCount)) {
              if (!input.trySkipNullValue()) {
                rollFormulaMaxCount = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1330223578:
          case -1656683273: {
            if (input.isAtField(FieldNames.rollFormulaFreeCount)) {
              if (!input.trySkipNullValue()) {
                rollFormulaFreeCount = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1509490790:
          case 1587811508: {
            if (input.isAtField(FieldNames.rollFormulaCount)) {
              if (!input.trySkipNullValue()) {
                rollFormulaCount = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1217175038:
          case 922300883: {
            if (input.isAtField(FieldNames.hintId)) {
              if (!input.trySkipNullValue()) {
                hintId = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 549719149:
          case -126477428: {
            if (input.isAtField(FieldNames.canRoll)) {
              if (!input.trySkipNullValue()) {
                canRoll = input.readBool();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 879485536:
          case 802830849: {
            if (input.isAtField(FieldNames.rollFormulaCostData)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(rollFormulaCostData);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 307771843:
          case -75392474: {
            if (input.isAtField(FieldNames.selectFormulaIdList)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(selectFormulaIdList);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -67362429:
          case 718902453: {
            if (input.isAtField(FieldNames.handbookUnlockFormulaIdList)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(handbookUnlockFormulaIdList);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public RogueFormulaSelectInfo clone() {
      return new RogueFormulaSelectInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RogueFormulaSelectInfo parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RogueFormulaSelectInfo(), data).checkInitialized();
    }

    public static RogueFormulaSelectInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new RogueFormulaSelectInfo(), input).checkInitialized();
    }

    public static RogueFormulaSelectInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new RogueFormulaSelectInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating RogueFormulaSelectInfo messages
     */
    public static MessageFactory<RogueFormulaSelectInfo> getFactory() {
      return RogueFormulaSelectInfoFactory.INSTANCE;
    }

    private enum RogueFormulaSelectInfoFactory implements MessageFactory<RogueFormulaSelectInfo> {
      INSTANCE;

      @Override
      public RogueFormulaSelectInfo create() {
        return RogueFormulaSelectInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName rollFormulaMaxCount = FieldName.forField("rollFormulaMaxCount", "roll_formula_max_count");

      static final FieldName rollFormulaFreeCount = FieldName.forField("rollFormulaFreeCount", "roll_formula_free_count");

      static final FieldName rollFormulaCount = FieldName.forField("rollFormulaCount", "roll_formula_count");

      static final FieldName hintId = FieldName.forField("hintId", "hint_id");

      static final FieldName canRoll = FieldName.forField("canRoll", "can_roll");

      static final FieldName rollFormulaCostData = FieldName.forField("rollFormulaCostData", "roll_formula_cost_data");

      static final FieldName selectFormulaIdList = FieldName.forField("selectFormulaIdList", "select_formula_id_list");

      static final FieldName handbookUnlockFormulaIdList = FieldName.forField("handbookUnlockFormulaIdList", "handbook_unlock_formula_id_list");
    }
  }
}
