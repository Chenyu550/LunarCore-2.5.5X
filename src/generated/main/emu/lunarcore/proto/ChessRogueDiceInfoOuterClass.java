// Code generated by protocol buffer compiler. Do not edit!
package emu.lunarcore.proto;

import java.io.IOException;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.RepeatedInt;

public final class ChessRogueDiceInfoOuterClass {
  /**
   * Protobuf type {@code ChessRogueDiceInfo}
   */
  public static final class ChessRogueDiceInfo extends ProtoMessage<ChessRogueDiceInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional int32 NHFELECMHIN = 944;</code>
     */
    private int nHFELECMHIN;

    /**
     * <code>optional uint32 reroll_times = 2;</code>
     */
    private int rerollTimes;

    /**
     * <code>optional uint32 cur_branch_id = 3;</code>
     */
    private int curBranchId;

    /**
     * <code>optional uint32 cur_surface_id = 4;</code>
     */
    private int curSurfaceId;

    /**
     * <code>optional uint32 CACKIGMCKFK = 8;</code>
     */
    private int cACKIGMCKFK;

    /**
     * <code>optional uint32 branch_id = 10;</code>
     */
    private int branchId;

    /**
     * <code>optional uint32 KDGGOKGJLMC = 11;</code>
     */
    private int kDGGOKGJLMC;

    /**
     * <code>optional uint32 cur_surface_index = 13;</code>
     */
    private int curSurfaceIndex;

    /**
     * <code>optional uint32 cheat_times = 14;</code>
     */
    private int cheatTimes;

    /**
     * <code>optional .ChessRogueDiceStatus dice_status = 9;</code>
     */
    private int diceStatus;

    /**
     * <code>optional .ChessRogueDiceType dice_type = 12;</code>
     */
    private int diceType;

    /**
     * <code>optional bool DPNCGPOLFKH = 15;</code>
     */
    private boolean dPNCGPOLFKH;

    /**
     * <code>optional bool can_reroll_dice = 162;</code>
     */
    private boolean canRerollDice;

    /**
     * <code>optional .ICNMLEMMHKL AMDLOMOGEOE = 263;</code>
     */
    private final ICNMLEMMHKLOuterClass.ICNMLEMMHKL aMDLOMOGEOE = ICNMLEMMHKLOuterClass.ICNMLEMMHKL.newInstance();

    /**
     * <code>optional .ChessRogueDice dice = 617;</code>
     */
    private final ChessRogueDiceOuterClass.ChessRogueDice dice = ChessRogueDiceOuterClass.ChessRogueDice.newInstance();

    /**
     * <code>optional .RogueModifier dice_modifier = 1741;</code>
     */
    private final RogueModifierOuterClass.RogueModifier diceModifier = RogueModifierOuterClass.RogueModifier.newInstance();

    /**
     * <code>repeated uint32 CLDNFIJILNP = 1633;</code>
     */
    private final RepeatedInt cLDNFIJILNP = RepeatedInt.newEmptyInstance();

    private ChessRogueDiceInfo() {
    }

    /**
     * @return a new empty instance of {@code ChessRogueDiceInfo}
     */
    public static ChessRogueDiceInfo newInstance() {
      return new ChessRogueDiceInfo();
    }

    /**
     * <code>optional int32 NHFELECMHIN = 944;</code>
     * @return whether the nHFELECMHIN field is set
     */
    public boolean hasNHFELECMHIN() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional int32 NHFELECMHIN = 944;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearNHFELECMHIN() {
      bitField0_ &= ~0x00000001;
      nHFELECMHIN = 0;
      return this;
    }

    /**
     * <code>optional int32 NHFELECMHIN = 944;</code>
     * @return the nHFELECMHIN
     */
    public int getNHFELECMHIN() {
      return nHFELECMHIN;
    }

    /**
     * <code>optional int32 NHFELECMHIN = 944;</code>
     * @param value the nHFELECMHIN to set
     * @return this
     */
    public ChessRogueDiceInfo setNHFELECMHIN(final int value) {
      bitField0_ |= 0x00000001;
      nHFELECMHIN = value;
      return this;
    }

    /**
     * <code>optional uint32 reroll_times = 2;</code>
     * @return whether the rerollTimes field is set
     */
    public boolean hasRerollTimes() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 reroll_times = 2;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearRerollTimes() {
      bitField0_ &= ~0x00000002;
      rerollTimes = 0;
      return this;
    }

    /**
     * <code>optional uint32 reroll_times = 2;</code>
     * @return the rerollTimes
     */
    public int getRerollTimes() {
      return rerollTimes;
    }

    /**
     * <code>optional uint32 reroll_times = 2;</code>
     * @param value the rerollTimes to set
     * @return this
     */
    public ChessRogueDiceInfo setRerollTimes(final int value) {
      bitField0_ |= 0x00000002;
      rerollTimes = value;
      return this;
    }

    /**
     * <code>optional uint32 cur_branch_id = 3;</code>
     * @return whether the curBranchId field is set
     */
    public boolean hasCurBranchId() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 cur_branch_id = 3;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearCurBranchId() {
      bitField0_ &= ~0x00000004;
      curBranchId = 0;
      return this;
    }

    /**
     * <code>optional uint32 cur_branch_id = 3;</code>
     * @return the curBranchId
     */
    public int getCurBranchId() {
      return curBranchId;
    }

    /**
     * <code>optional uint32 cur_branch_id = 3;</code>
     * @param value the curBranchId to set
     * @return this
     */
    public ChessRogueDiceInfo setCurBranchId(final int value) {
      bitField0_ |= 0x00000004;
      curBranchId = value;
      return this;
    }

    /**
     * <code>optional uint32 cur_surface_id = 4;</code>
     * @return whether the curSurfaceId field is set
     */
    public boolean hasCurSurfaceId() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 cur_surface_id = 4;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearCurSurfaceId() {
      bitField0_ &= ~0x00000008;
      curSurfaceId = 0;
      return this;
    }

    /**
     * <code>optional uint32 cur_surface_id = 4;</code>
     * @return the curSurfaceId
     */
    public int getCurSurfaceId() {
      return curSurfaceId;
    }

    /**
     * <code>optional uint32 cur_surface_id = 4;</code>
     * @param value the curSurfaceId to set
     * @return this
     */
    public ChessRogueDiceInfo setCurSurfaceId(final int value) {
      bitField0_ |= 0x00000008;
      curSurfaceId = value;
      return this;
    }

    /**
     * <code>optional uint32 CACKIGMCKFK = 8;</code>
     * @return whether the cACKIGMCKFK field is set
     */
    public boolean hasCACKIGMCKFK() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 CACKIGMCKFK = 8;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearCACKIGMCKFK() {
      bitField0_ &= ~0x00000010;
      cACKIGMCKFK = 0;
      return this;
    }

    /**
     * <code>optional uint32 CACKIGMCKFK = 8;</code>
     * @return the cACKIGMCKFK
     */
    public int getCACKIGMCKFK() {
      return cACKIGMCKFK;
    }

    /**
     * <code>optional uint32 CACKIGMCKFK = 8;</code>
     * @param value the cACKIGMCKFK to set
     * @return this
     */
    public ChessRogueDiceInfo setCACKIGMCKFK(final int value) {
      bitField0_ |= 0x00000010;
      cACKIGMCKFK = value;
      return this;
    }

    /**
     * <code>optional uint32 branch_id = 10;</code>
     * @return whether the branchId field is set
     */
    public boolean hasBranchId() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional uint32 branch_id = 10;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearBranchId() {
      bitField0_ &= ~0x00000020;
      branchId = 0;
      return this;
    }

    /**
     * <code>optional uint32 branch_id = 10;</code>
     * @return the branchId
     */
    public int getBranchId() {
      return branchId;
    }

    /**
     * <code>optional uint32 branch_id = 10;</code>
     * @param value the branchId to set
     * @return this
     */
    public ChessRogueDiceInfo setBranchId(final int value) {
      bitField0_ |= 0x00000020;
      branchId = value;
      return this;
    }

    /**
     * <code>optional uint32 KDGGOKGJLMC = 11;</code>
     * @return whether the kDGGOKGJLMC field is set
     */
    public boolean hasKDGGOKGJLMC() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional uint32 KDGGOKGJLMC = 11;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearKDGGOKGJLMC() {
      bitField0_ &= ~0x00000040;
      kDGGOKGJLMC = 0;
      return this;
    }

    /**
     * <code>optional uint32 KDGGOKGJLMC = 11;</code>
     * @return the kDGGOKGJLMC
     */
    public int getKDGGOKGJLMC() {
      return kDGGOKGJLMC;
    }

    /**
     * <code>optional uint32 KDGGOKGJLMC = 11;</code>
     * @param value the kDGGOKGJLMC to set
     * @return this
     */
    public ChessRogueDiceInfo setKDGGOKGJLMC(final int value) {
      bitField0_ |= 0x00000040;
      kDGGOKGJLMC = value;
      return this;
    }

    /**
     * <code>optional uint32 cur_surface_index = 13;</code>
     * @return whether the curSurfaceIndex field is set
     */
    public boolean hasCurSurfaceIndex() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional uint32 cur_surface_index = 13;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearCurSurfaceIndex() {
      bitField0_ &= ~0x00000080;
      curSurfaceIndex = 0;
      return this;
    }

    /**
     * <code>optional uint32 cur_surface_index = 13;</code>
     * @return the curSurfaceIndex
     */
    public int getCurSurfaceIndex() {
      return curSurfaceIndex;
    }

    /**
     * <code>optional uint32 cur_surface_index = 13;</code>
     * @param value the curSurfaceIndex to set
     * @return this
     */
    public ChessRogueDiceInfo setCurSurfaceIndex(final int value) {
      bitField0_ |= 0x00000080;
      curSurfaceIndex = value;
      return this;
    }

    /**
     * <code>optional uint32 cheat_times = 14;</code>
     * @return whether the cheatTimes field is set
     */
    public boolean hasCheatTimes() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional uint32 cheat_times = 14;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearCheatTimes() {
      bitField0_ &= ~0x00000100;
      cheatTimes = 0;
      return this;
    }

    /**
     * <code>optional uint32 cheat_times = 14;</code>
     * @return the cheatTimes
     */
    public int getCheatTimes() {
      return cheatTimes;
    }

    /**
     * <code>optional uint32 cheat_times = 14;</code>
     * @param value the cheatTimes to set
     * @return this
     */
    public ChessRogueDiceInfo setCheatTimes(final int value) {
      bitField0_ |= 0x00000100;
      cheatTimes = value;
      return this;
    }

    /**
     * <code>optional .ChessRogueDiceStatus dice_status = 9;</code>
     * @return whether the diceStatus field is set
     */
    public boolean hasDiceStatus() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional .ChessRogueDiceStatus dice_status = 9;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearDiceStatus() {
      bitField0_ &= ~0x00000200;
      diceStatus = 0;
      return this;
    }

    /**
     * <code>optional .ChessRogueDiceStatus dice_status = 9;</code>
     * @return the diceStatus
     */
    public ChessRogueDiceStatusOuterClass.ChessRogueDiceStatus getDiceStatus() {
      return ChessRogueDiceStatusOuterClass.ChessRogueDiceStatus.forNumber(diceStatus);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link ChessRogueDiceInfo#getDiceStatus()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getDiceStatusValue() {
      return diceStatus;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link ChessRogueDiceStatusOuterClass.ChessRogueDiceStatus}. Setting an invalid value
     * can cause {@link ChessRogueDiceInfo#getDiceStatus()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public ChessRogueDiceInfo setDiceStatusValue(final int value) {
      bitField0_ |= 0x00000200;
      diceStatus = value;
      return this;
    }

    /**
     * <code>optional .ChessRogueDiceStatus dice_status = 9;</code>
     * @param value the diceStatus to set
     * @return this
     */
    public ChessRogueDiceInfo setDiceStatus(
        final ChessRogueDiceStatusOuterClass.ChessRogueDiceStatus value) {
      bitField0_ |= 0x00000200;
      diceStatus = value.getNumber();
      return this;
    }

    /**
     * <code>optional .ChessRogueDiceType dice_type = 12;</code>
     * @return whether the diceType field is set
     */
    public boolean hasDiceType() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>optional .ChessRogueDiceType dice_type = 12;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearDiceType() {
      bitField0_ &= ~0x00000400;
      diceType = 0;
      return this;
    }

    /**
     * <code>optional .ChessRogueDiceType dice_type = 12;</code>
     * @return the diceType
     */
    public ChessRogueDiceTypeOuterClass.ChessRogueDiceType getDiceType() {
      return ChessRogueDiceTypeOuterClass.ChessRogueDiceType.forNumber(diceType);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link ChessRogueDiceInfo#getDiceType()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getDiceTypeValue() {
      return diceType;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link ChessRogueDiceTypeOuterClass.ChessRogueDiceType}. Setting an invalid value
     * can cause {@link ChessRogueDiceInfo#getDiceType()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public ChessRogueDiceInfo setDiceTypeValue(final int value) {
      bitField0_ |= 0x00000400;
      diceType = value;
      return this;
    }

    /**
     * <code>optional .ChessRogueDiceType dice_type = 12;</code>
     * @param value the diceType to set
     * @return this
     */
    public ChessRogueDiceInfo setDiceType(
        final ChessRogueDiceTypeOuterClass.ChessRogueDiceType value) {
      bitField0_ |= 0x00000400;
      diceType = value.getNumber();
      return this;
    }

    /**
     * <code>optional bool DPNCGPOLFKH = 15;</code>
     * @return whether the dPNCGPOLFKH field is set
     */
    public boolean hasDPNCGPOLFKH() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>optional bool DPNCGPOLFKH = 15;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearDPNCGPOLFKH() {
      bitField0_ &= ~0x00000800;
      dPNCGPOLFKH = false;
      return this;
    }

    /**
     * <code>optional bool DPNCGPOLFKH = 15;</code>
     * @return the dPNCGPOLFKH
     */
    public boolean getDPNCGPOLFKH() {
      return dPNCGPOLFKH;
    }

    /**
     * <code>optional bool DPNCGPOLFKH = 15;</code>
     * @param value the dPNCGPOLFKH to set
     * @return this
     */
    public ChessRogueDiceInfo setDPNCGPOLFKH(final boolean value) {
      bitField0_ |= 0x00000800;
      dPNCGPOLFKH = value;
      return this;
    }

    /**
     * <code>optional bool can_reroll_dice = 162;</code>
     * @return whether the canRerollDice field is set
     */
    public boolean hasCanRerollDice() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>optional bool can_reroll_dice = 162;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearCanRerollDice() {
      bitField0_ &= ~0x00001000;
      canRerollDice = false;
      return this;
    }

    /**
     * <code>optional bool can_reroll_dice = 162;</code>
     * @return the canRerollDice
     */
    public boolean getCanRerollDice() {
      return canRerollDice;
    }

    /**
     * <code>optional bool can_reroll_dice = 162;</code>
     * @param value the canRerollDice to set
     * @return this
     */
    public ChessRogueDiceInfo setCanRerollDice(final boolean value) {
      bitField0_ |= 0x00001000;
      canRerollDice = value;
      return this;
    }

    /**
     * <code>optional .ICNMLEMMHKL AMDLOMOGEOE = 263;</code>
     * @return whether the aMDLOMOGEOE field is set
     */
    public boolean hasAMDLOMOGEOE() {
      return (bitField0_ & 0x00002000) != 0;
    }

    /**
     * <code>optional .ICNMLEMMHKL AMDLOMOGEOE = 263;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearAMDLOMOGEOE() {
      bitField0_ &= ~0x00002000;
      aMDLOMOGEOE.clear();
      return this;
    }

    /**
     * <code>optional .ICNMLEMMHKL AMDLOMOGEOE = 263;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableAMDLOMOGEOE()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ICNMLEMMHKLOuterClass.ICNMLEMMHKL getAMDLOMOGEOE() {
      return aMDLOMOGEOE;
    }

    /**
     * <code>optional .ICNMLEMMHKL AMDLOMOGEOE = 263;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ICNMLEMMHKLOuterClass.ICNMLEMMHKL getMutableAMDLOMOGEOE() {
      bitField0_ |= 0x00002000;
      return aMDLOMOGEOE;
    }

    /**
     * <code>optional .ICNMLEMMHKL AMDLOMOGEOE = 263;</code>
     * @param value the aMDLOMOGEOE to set
     * @return this
     */
    public ChessRogueDiceInfo setAMDLOMOGEOE(final ICNMLEMMHKLOuterClass.ICNMLEMMHKL value) {
      bitField0_ |= 0x00002000;
      aMDLOMOGEOE.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .ChessRogueDice dice = 617;</code>
     * @return whether the dice field is set
     */
    public boolean hasDice() {
      return (bitField0_ & 0x00004000) != 0;
    }

    /**
     * <code>optional .ChessRogueDice dice = 617;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearDice() {
      bitField0_ &= ~0x00004000;
      dice.clear();
      return this;
    }

    /**
     * <code>optional .ChessRogueDice dice = 617;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDice()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ChessRogueDiceOuterClass.ChessRogueDice getDice() {
      return dice;
    }

    /**
     * <code>optional .ChessRogueDice dice = 617;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ChessRogueDiceOuterClass.ChessRogueDice getMutableDice() {
      bitField0_ |= 0x00004000;
      return dice;
    }

    /**
     * <code>optional .ChessRogueDice dice = 617;</code>
     * @param value the dice to set
     * @return this
     */
    public ChessRogueDiceInfo setDice(final ChessRogueDiceOuterClass.ChessRogueDice value) {
      bitField0_ |= 0x00004000;
      dice.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .RogueModifier dice_modifier = 1741;</code>
     * @return whether the diceModifier field is set
     */
    public boolean hasDiceModifier() {
      return (bitField0_ & 0x00008000) != 0;
    }

    /**
     * <code>optional .RogueModifier dice_modifier = 1741;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearDiceModifier() {
      bitField0_ &= ~0x00008000;
      diceModifier.clear();
      return this;
    }

    /**
     * <code>optional .RogueModifier dice_modifier = 1741;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableDiceModifier()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RogueModifierOuterClass.RogueModifier getDiceModifier() {
      return diceModifier;
    }

    /**
     * <code>optional .RogueModifier dice_modifier = 1741;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RogueModifierOuterClass.RogueModifier getMutableDiceModifier() {
      bitField0_ |= 0x00008000;
      return diceModifier;
    }

    /**
     * <code>optional .RogueModifier dice_modifier = 1741;</code>
     * @param value the diceModifier to set
     * @return this
     */
    public ChessRogueDiceInfo setDiceModifier(final RogueModifierOuterClass.RogueModifier value) {
      bitField0_ |= 0x00008000;
      diceModifier.copyFrom(value);
      return this;
    }

    /**
     * <code>repeated uint32 CLDNFIJILNP = 1633;</code>
     * @return whether the cLDNFIJILNP field is set
     */
    public boolean hasCLDNFIJILNP() {
      return (bitField0_ & 0x00010000) != 0;
    }

    /**
     * <code>repeated uint32 CLDNFIJILNP = 1633;</code>
     * @return this
     */
    public ChessRogueDiceInfo clearCLDNFIJILNP() {
      bitField0_ &= ~0x00010000;
      cLDNFIJILNP.clear();
      return this;
    }

    /**
     * <code>repeated uint32 CLDNFIJILNP = 1633;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableCLDNFIJILNP()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getCLDNFIJILNP() {
      return cLDNFIJILNP;
    }

    /**
     * <code>repeated uint32 CLDNFIJILNP = 1633;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableCLDNFIJILNP() {
      bitField0_ |= 0x00010000;
      return cLDNFIJILNP;
    }

    /**
     * <code>repeated uint32 CLDNFIJILNP = 1633;</code>
     * @param value the cLDNFIJILNP to add
     * @return this
     */
    public ChessRogueDiceInfo addCLDNFIJILNP(final int value) {
      bitField0_ |= 0x00010000;
      cLDNFIJILNP.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 CLDNFIJILNP = 1633;</code>
     * @param values the cLDNFIJILNP to add
     * @return this
     */
    public ChessRogueDiceInfo addAllCLDNFIJILNP(final int... values) {
      bitField0_ |= 0x00010000;
      cLDNFIJILNP.addAll(values);
      return this;
    }

    @Override
    public ChessRogueDiceInfo copyFrom(final ChessRogueDiceInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        nHFELECMHIN = other.nHFELECMHIN;
        rerollTimes = other.rerollTimes;
        curBranchId = other.curBranchId;
        curSurfaceId = other.curSurfaceId;
        cACKIGMCKFK = other.cACKIGMCKFK;
        branchId = other.branchId;
        kDGGOKGJLMC = other.kDGGOKGJLMC;
        curSurfaceIndex = other.curSurfaceIndex;
        cheatTimes = other.cheatTimes;
        diceStatus = other.diceStatus;
        diceType = other.diceType;
        dPNCGPOLFKH = other.dPNCGPOLFKH;
        canRerollDice = other.canRerollDice;
        aMDLOMOGEOE.copyFrom(other.aMDLOMOGEOE);
        dice.copyFrom(other.dice);
        diceModifier.copyFrom(other.diceModifier);
        cLDNFIJILNP.copyFrom(other.cLDNFIJILNP);
      }
      return this;
    }

    @Override
    public ChessRogueDiceInfo mergeFrom(final ChessRogueDiceInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasNHFELECMHIN()) {
        setNHFELECMHIN(other.nHFELECMHIN);
      }
      if (other.hasRerollTimes()) {
        setRerollTimes(other.rerollTimes);
      }
      if (other.hasCurBranchId()) {
        setCurBranchId(other.curBranchId);
      }
      if (other.hasCurSurfaceId()) {
        setCurSurfaceId(other.curSurfaceId);
      }
      if (other.hasCACKIGMCKFK()) {
        setCACKIGMCKFK(other.cACKIGMCKFK);
      }
      if (other.hasBranchId()) {
        setBranchId(other.branchId);
      }
      if (other.hasKDGGOKGJLMC()) {
        setKDGGOKGJLMC(other.kDGGOKGJLMC);
      }
      if (other.hasCurSurfaceIndex()) {
        setCurSurfaceIndex(other.curSurfaceIndex);
      }
      if (other.hasCheatTimes()) {
        setCheatTimes(other.cheatTimes);
      }
      if (other.hasDiceStatus()) {
        setDiceStatusValue(other.diceStatus);
      }
      if (other.hasDiceType()) {
        setDiceTypeValue(other.diceType);
      }
      if (other.hasDPNCGPOLFKH()) {
        setDPNCGPOLFKH(other.dPNCGPOLFKH);
      }
      if (other.hasCanRerollDice()) {
        setCanRerollDice(other.canRerollDice);
      }
      if (other.hasAMDLOMOGEOE()) {
        getMutableAMDLOMOGEOE().mergeFrom(other.aMDLOMOGEOE);
      }
      if (other.hasDice()) {
        getMutableDice().mergeFrom(other.dice);
      }
      if (other.hasDiceModifier()) {
        getMutableDiceModifier().mergeFrom(other.diceModifier);
      }
      if (other.hasCLDNFIJILNP()) {
        getMutableCLDNFIJILNP().addAll(other.cLDNFIJILNP);
      }
      return this;
    }

    @Override
    public ChessRogueDiceInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      nHFELECMHIN = 0;
      rerollTimes = 0;
      curBranchId = 0;
      curSurfaceId = 0;
      cACKIGMCKFK = 0;
      branchId = 0;
      kDGGOKGJLMC = 0;
      curSurfaceIndex = 0;
      cheatTimes = 0;
      diceStatus = 0;
      diceType = 0;
      dPNCGPOLFKH = false;
      canRerollDice = false;
      aMDLOMOGEOE.clear();
      dice.clear();
      diceModifier.clear();
      cLDNFIJILNP.clear();
      return this;
    }

    @Override
    public ChessRogueDiceInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      aMDLOMOGEOE.clearQuick();
      dice.clearQuick();
      diceModifier.clearQuick();
      cLDNFIJILNP.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ChessRogueDiceInfo)) {
        return false;
      }
      ChessRogueDiceInfo other = (ChessRogueDiceInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasNHFELECMHIN() || nHFELECMHIN == other.nHFELECMHIN)
        && (!hasRerollTimes() || rerollTimes == other.rerollTimes)
        && (!hasCurBranchId() || curBranchId == other.curBranchId)
        && (!hasCurSurfaceId() || curSurfaceId == other.curSurfaceId)
        && (!hasCACKIGMCKFK() || cACKIGMCKFK == other.cACKIGMCKFK)
        && (!hasBranchId() || branchId == other.branchId)
        && (!hasKDGGOKGJLMC() || kDGGOKGJLMC == other.kDGGOKGJLMC)
        && (!hasCurSurfaceIndex() || curSurfaceIndex == other.curSurfaceIndex)
        && (!hasCheatTimes() || cheatTimes == other.cheatTimes)
        && (!hasDiceStatus() || diceStatus == other.diceStatus)
        && (!hasDiceType() || diceType == other.diceType)
        && (!hasDPNCGPOLFKH() || dPNCGPOLFKH == other.dPNCGPOLFKH)
        && (!hasCanRerollDice() || canRerollDice == other.canRerollDice)
        && (!hasAMDLOMOGEOE() || aMDLOMOGEOE.equals(other.aMDLOMOGEOE))
        && (!hasDice() || dice.equals(other.dice))
        && (!hasDiceModifier() || diceModifier.equals(other.diceModifier))
        && (!hasCLDNFIJILNP() || cLDNFIJILNP.equals(other.cLDNFIJILNP));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawLittleEndian16((short) 15232);
        output.writeInt32NoTag(nHFELECMHIN);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(rerollTimes);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 24);
        output.writeUInt32NoTag(curBranchId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 32);
        output.writeUInt32NoTag(curSurfaceId);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 64);
        output.writeUInt32NoTag(cACKIGMCKFK);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 80);
        output.writeUInt32NoTag(branchId);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 88);
        output.writeUInt32NoTag(kDGGOKGJLMC);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 104);
        output.writeUInt32NoTag(curSurfaceIndex);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawByte((byte) 112);
        output.writeUInt32NoTag(cheatTimes);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawByte((byte) 72);
        output.writeEnumNoTag(diceStatus);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRawByte((byte) 96);
        output.writeEnumNoTag(diceType);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRawByte((byte) 120);
        output.writeBoolNoTag(dPNCGPOLFKH);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeRawLittleEndian16((short) 2704);
        output.writeBoolNoTag(canRerollDice);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        output.writeRawLittleEndian16((short) 4282);
        output.writeMessageNoTag(aMDLOMOGEOE);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        output.writeRawLittleEndian16((short) 9930);
        output.writeMessageNoTag(dice);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        output.writeRawLittleEndian16((short) 27882);
        output.writeMessageNoTag(diceModifier);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        for (int i = 0; i < cLDNFIJILNP.length(); i++) {
          output.writeRawLittleEndian16((short) 26248);
          output.writeUInt32NoTag(cLDNFIJILNP.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 2 + ProtoSink.computeInt32SizeNoTag(nHFELECMHIN);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(rerollTimes);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(curBranchId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(curSurfaceId);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(cACKIGMCKFK);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(branchId);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(kDGGOKGJLMC);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(curSurfaceIndex);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(cheatTimes);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(diceStatus);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(diceType);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00001000) != 0) {
        size += 3;
      }
      if ((bitField0_ & 0x00002000) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(aMDLOMOGEOE);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(dice);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(diceModifier);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        size += (2 * cLDNFIJILNP.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(cLDNFIJILNP);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ChessRogueDiceInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 7552: {
            // nHFELECMHIN
            nHFELECMHIN = input.readInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // rerollTimes
            rerollTimes = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 24) {
              break;
            }
          }
          case 24: {
            // curBranchId
            curBranchId = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // curSurfaceId
            curSurfaceId = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 64) {
              break;
            }
          }
          case 64: {
            // cACKIGMCKFK
            cACKIGMCKFK = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 80) {
              break;
            }
          }
          case 80: {
            // branchId
            branchId = input.readUInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 88) {
              break;
            }
          }
          case 88: {
            // kDGGOKGJLMC
            kDGGOKGJLMC = input.readUInt32();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 104) {
              break;
            }
          }
          case 104: {
            // curSurfaceIndex
            curSurfaceIndex = input.readUInt32();
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 112) {
              break;
            }
          }
          case 112: {
            // cheatTimes
            cheatTimes = input.readUInt32();
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 72) {
              break;
            }
          }
          case 72: {
            // diceStatus
            final int value = input.readInt32();
            if (ChessRogueDiceStatusOuterClass.ChessRogueDiceStatus.forNumber(value) != null) {
              diceStatus = value;
              bitField0_ |= 0x00000200;
            }
            tag = input.readTag();
            if (tag != 96) {
              break;
            }
          }
          case 96: {
            // diceType
            final int value = input.readInt32();
            if (ChessRogueDiceTypeOuterClass.ChessRogueDiceType.forNumber(value) != null) {
              diceType = value;
              bitField0_ |= 0x00000400;
            }
            tag = input.readTag();
            if (tag != 120) {
              break;
            }
          }
          case 120: {
            // dPNCGPOLFKH
            dPNCGPOLFKH = input.readBool();
            bitField0_ |= 0x00000800;
            tag = input.readTag();
            if (tag != 1296) {
              break;
            }
          }
          case 1296: {
            // canRerollDice
            canRerollDice = input.readBool();
            bitField0_ |= 0x00001000;
            tag = input.readTag();
            if (tag != 2106) {
              break;
            }
          }
          case 2106: {
            // aMDLOMOGEOE
            input.readMessage(aMDLOMOGEOE);
            bitField0_ |= 0x00002000;
            tag = input.readTag();
            if (tag != 4938) {
              break;
            }
          }
          case 4938: {
            // dice
            input.readMessage(dice);
            bitField0_ |= 0x00004000;
            tag = input.readTag();
            if (tag != 13930) {
              break;
            }
          }
          case 13930: {
            // diceModifier
            input.readMessage(diceModifier);
            bitField0_ |= 0x00008000;
            tag = input.readTag();
            if (tag != 13066) {
              break;
            }
          }
          case 13066: {
            // cLDNFIJILNP [packed=true]
            input.readPackedUInt32(cLDNFIJILNP, tag);
            bitField0_ |= 0x00010000;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 13064: {
            // cLDNFIJILNP [packed=false]
            tag = input.readRepeatedUInt32(cLDNFIJILNP, tag);
            bitField0_ |= 0x00010000;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeInt32(FieldNames.nHFELECMHIN, nHFELECMHIN);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.rerollTimes, rerollTimes);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.curBranchId, curBranchId);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.curSurfaceId, curSurfaceId);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.cACKIGMCKFK, cACKIGMCKFK);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeUInt32(FieldNames.branchId, branchId);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeUInt32(FieldNames.kDGGOKGJLMC, kDGGOKGJLMC);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeUInt32(FieldNames.curSurfaceIndex, curSurfaceIndex);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeUInt32(FieldNames.cheatTimes, cheatTimes);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeEnum(FieldNames.diceStatus, diceStatus, ChessRogueDiceStatusOuterClass.ChessRogueDiceStatus.converter());
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeEnum(FieldNames.diceType, diceType, ChessRogueDiceTypeOuterClass.ChessRogueDiceType.converter());
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeBool(FieldNames.dPNCGPOLFKH, dPNCGPOLFKH);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeBool(FieldNames.canRerollDice, canRerollDice);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        output.writeMessage(FieldNames.aMDLOMOGEOE, aMDLOMOGEOE);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        output.writeMessage(FieldNames.dice, dice);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        output.writeMessage(FieldNames.diceModifier, diceModifier);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        output.writeRepeatedUInt32(FieldNames.cLDNFIJILNP, cLDNFIJILNP);
      }
      output.endObject();
    }

    @Override
    public ChessRogueDiceInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case -894831919: {
            if (input.isAtField(FieldNames.nHFELECMHIN)) {
              if (!input.trySkipNullValue()) {
                nHFELECMHIN = input.readInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -836069386:
          case 176620407: {
            if (input.isAtField(FieldNames.rerollTimes)) {
              if (!input.trySkipNullValue()) {
                rerollTimes = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1121055933:
          case -2029879911: {
            if (input.isAtField(FieldNames.curBranchId)) {
              if (!input.trySkipNullValue()) {
                curBranchId = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1658805176:
          case -1978690228: {
            if (input.isAtField(FieldNames.curSurfaceId)) {
              if (!input.trySkipNullValue()) {
                curSurfaceId = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -829598058: {
            if (input.isAtField(FieldNames.cACKIGMCKFK)) {
              if (!input.trySkipNullValue()) {
                cACKIGMCKFK = input.readUInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -25407907:
          case -787623720: {
            if (input.isAtField(FieldNames.branchId)) {
              if (!input.trySkipNullValue()) {
                branchId = input.readUInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1208202410: {
            if (input.isAtField(FieldNames.kDGGOKGJLMC)) {
              if (!input.trySkipNullValue()) {
                kDGGOKGJLMC = input.readUInt32();
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 429106821:
          case 1265952513: {
            if (input.isAtField(FieldNames.curSurfaceIndex)) {
              if (!input.trySkipNullValue()) {
                curSurfaceIndex = input.readUInt32();
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2046149069:
          case 1318855898: {
            if (input.isAtField(FieldNames.cheatTimes)) {
              if (!input.trySkipNullValue()) {
                cheatTimes = input.readUInt32();
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -606196103:
          case 436250506: {
            if (input.isAtField(FieldNames.diceStatus)) {
              if (!input.trySkipNullValue()) {
                final ChessRogueDiceStatusOuterClass.ChessRogueDiceStatus value = input.readEnum(ChessRogueDiceStatusOuterClass.ChessRogueDiceStatus.converter());
                if (value != null) {
                  diceStatus = value.getNumber();
                  bitField0_ |= 0x00000200;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -183835775:
          case -1393922862: {
            if (input.isAtField(FieldNames.diceType)) {
              if (!input.trySkipNullValue()) {
                final ChessRogueDiceTypeOuterClass.ChessRogueDiceType value = input.readEnum(ChessRogueDiceTypeOuterClass.ChessRogueDiceType.converter());
                if (value != null) {
                  diceType = value.getNumber();
                  bitField0_ |= 0x00000400;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2035704700: {
            if (input.isAtField(FieldNames.dPNCGPOLFKH)) {
              if (!input.trySkipNullValue()) {
                dPNCGPOLFKH = input.readBool();
                bitField0_ |= 0x00000800;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -801276697:
          case 2061495143: {
            if (input.isAtField(FieldNames.canRerollDice)) {
              if (!input.trySkipNullValue()) {
                canRerollDice = input.readBool();
                bitField0_ |= 0x00001000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1545288881: {
            if (input.isAtField(FieldNames.aMDLOMOGEOE)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(aMDLOMOGEOE);
                bitField0_ |= 0x00002000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 3083175: {
            if (input.isAtField(FieldNames.dice)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(dice);
                bitField0_ |= 0x00004000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -373105762:
          case 690705519: {
            if (input.isAtField(FieldNames.diceModifier)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(diceModifier);
                bitField0_ |= 0x00008000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 2116853881: {
            if (input.isAtField(FieldNames.cLDNFIJILNP)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(cLDNFIJILNP);
                bitField0_ |= 0x00010000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ChessRogueDiceInfo clone() {
      return new ChessRogueDiceInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ChessRogueDiceInfo parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ChessRogueDiceInfo(), data).checkInitialized();
    }

    public static ChessRogueDiceInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ChessRogueDiceInfo(), input).checkInitialized();
    }

    public static ChessRogueDiceInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ChessRogueDiceInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating ChessRogueDiceInfo messages
     */
    public static MessageFactory<ChessRogueDiceInfo> getFactory() {
      return ChessRogueDiceInfoFactory.INSTANCE;
    }

    private enum ChessRogueDiceInfoFactory implements MessageFactory<ChessRogueDiceInfo> {
      INSTANCE;

      @Override
      public ChessRogueDiceInfo create() {
        return ChessRogueDiceInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName nHFELECMHIN = FieldName.forField("NHFELECMHIN");

      static final FieldName rerollTimes = FieldName.forField("rerollTimes", "reroll_times");

      static final FieldName curBranchId = FieldName.forField("curBranchId", "cur_branch_id");

      static final FieldName curSurfaceId = FieldName.forField("curSurfaceId", "cur_surface_id");

      static final FieldName cACKIGMCKFK = FieldName.forField("CACKIGMCKFK");

      static final FieldName branchId = FieldName.forField("branchId", "branch_id");

      static final FieldName kDGGOKGJLMC = FieldName.forField("KDGGOKGJLMC");

      static final FieldName curSurfaceIndex = FieldName.forField("curSurfaceIndex", "cur_surface_index");

      static final FieldName cheatTimes = FieldName.forField("cheatTimes", "cheat_times");

      static final FieldName diceStatus = FieldName.forField("diceStatus", "dice_status");

      static final FieldName diceType = FieldName.forField("diceType", "dice_type");

      static final FieldName dPNCGPOLFKH = FieldName.forField("DPNCGPOLFKH");

      static final FieldName canRerollDice = FieldName.forField("canRerollDice", "can_reroll_dice");

      static final FieldName aMDLOMOGEOE = FieldName.forField("AMDLOMOGEOE");

      static final FieldName dice = FieldName.forField("dice");

      static final FieldName diceModifier = FieldName.forField("diceModifier", "dice_modifier");

      static final FieldName cLDNFIJILNP = FieldName.forField("CLDNFIJILNP");
    }
  }
}
