// Code generated by protocol buffer compiler. Do not edit!
package emu.lunarcore.proto;

import java.io.IOException;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.RepeatedInt;

public final class ChessRogueFinishInfoOuterClass {
  /**
   * Protobuf type {@code ChessRogueFinishInfo}
   */
  public static final class ChessRogueFinishInfo extends ProtoMessage<ChessRogueFinishInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional uint32 end_area_id = 1;</code>
     */
    private int endAreaId;

    /**
     * <code>optional uint32 last_layer_id = 2;</code>
     */
    private int lastLayerId;

    /**
     * <code>optional uint32 DODPBNFKKEL = 6;</code>
     */
    private int dODPBNFKKEL;

    /**
     * <code>optional uint32 chess_rogue_main_story_id = 9;</code>
     */
    private int chessRogueMainStoryId;

    /**
     * <code>optional uint32 difficulty_level = 11;</code>
     */
    private int difficultyLevel;

    /**
     * <code>optional uint32 OLMBPLAIMLP = 15;</code>
     */
    private int oLMBPLAIMLP;

    /**
     * <code>optional uint32 score_id = 468;</code>
     */
    private int scoreId;

    /**
     * <code>optional uint32 rogue_sub_mode = 862;</code>
     */
    private int rogueSubMode;

    /**
     * <code>optional uint32 BIOHIBDDDFG = 912;</code>
     */
    private int bIOHIBDDDFG;

    /**
     * <code>optional uint32 LEBECEFMDJN = 1129;</code>
     */
    private int lEBECEFMDJN;

    /**
     * <code>optional uint32 CNCAOLEDBDI = 1705;</code>
     */
    private int cNCAOLEDBDI;

    /**
     * <code>optional .ChessRogueQuitReason quit_reason = 14;</code>
     */
    private int quitReason;

    /**
     * <code>optional bool is_finish = 4;</code>
     */
    private boolean isFinish;

    /**
     * <code>optional .ItemList EPGJCMNBIPJ = 3;</code>
     */
    private final ItemListOuterClass.ItemList ePGJCMNBIPJ = ItemListOuterClass.ItemList.newInstance();

    /**
     * <code>optional .ChessRogueBuff rogue_buff_info = 7;</code>
     */
    private final ChessRogueBuffOuterClass.ChessRogueBuff rogueBuffInfo = ChessRogueBuffOuterClass.ChessRogueBuff.newInstance();

    /**
     * <code>optional .LineupInfo rogue_lineup = 10;</code>
     */
    private final LineupInfoOuterClass.LineupInfo rogueLineup = LineupInfoOuterClass.LineupInfo.newInstance();

    /**
     * <code>optional .ChessRogueMiracle game_miracle_info = 12;</code>
     */
    private final ChessRogueMiracleOuterClass.ChessRogueMiracle gameMiracleInfo = ChessRogueMiracleOuterClass.ChessRogueMiracle.newInstance();

    /**
     * <code>optional .JPFECHLHHEN NKGKDMFHGFJ = 1250;</code>
     */
    private final JPFECHLHHENOuterClass.JPFECHLHHEN nKGKDMFHGFJ = JPFECHLHHENOuterClass.JPFECHLHHEN.newInstance();

    /**
     * <code>repeated uint32 HHMFIDKFNNI = 5;</code>
     */
    private final RepeatedInt hHMFIDKFNNI = RepeatedInt.newEmptyInstance();

    private ChessRogueFinishInfo() {
    }

    /**
     * @return a new empty instance of {@code ChessRogueFinishInfo}
     */
    public static ChessRogueFinishInfo newInstance() {
      return new ChessRogueFinishInfo();
    }

    /**
     * <code>optional uint32 end_area_id = 1;</code>
     * @return whether the endAreaId field is set
     */
    public boolean hasEndAreaId() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional uint32 end_area_id = 1;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearEndAreaId() {
      bitField0_ &= ~0x00000001;
      endAreaId = 0;
      return this;
    }

    /**
     * <code>optional uint32 end_area_id = 1;</code>
     * @return the endAreaId
     */
    public int getEndAreaId() {
      return endAreaId;
    }

    /**
     * <code>optional uint32 end_area_id = 1;</code>
     * @param value the endAreaId to set
     * @return this
     */
    public ChessRogueFinishInfo setEndAreaId(final int value) {
      bitField0_ |= 0x00000001;
      endAreaId = value;
      return this;
    }

    /**
     * <code>optional uint32 last_layer_id = 2;</code>
     * @return whether the lastLayerId field is set
     */
    public boolean hasLastLayerId() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional uint32 last_layer_id = 2;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearLastLayerId() {
      bitField0_ &= ~0x00000002;
      lastLayerId = 0;
      return this;
    }

    /**
     * <code>optional uint32 last_layer_id = 2;</code>
     * @return the lastLayerId
     */
    public int getLastLayerId() {
      return lastLayerId;
    }

    /**
     * <code>optional uint32 last_layer_id = 2;</code>
     * @param value the lastLayerId to set
     * @return this
     */
    public ChessRogueFinishInfo setLastLayerId(final int value) {
      bitField0_ |= 0x00000002;
      lastLayerId = value;
      return this;
    }

    /**
     * <code>optional uint32 DODPBNFKKEL = 6;</code>
     * @return whether the dODPBNFKKEL field is set
     */
    public boolean hasDODPBNFKKEL() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional uint32 DODPBNFKKEL = 6;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearDODPBNFKKEL() {
      bitField0_ &= ~0x00000004;
      dODPBNFKKEL = 0;
      return this;
    }

    /**
     * <code>optional uint32 DODPBNFKKEL = 6;</code>
     * @return the dODPBNFKKEL
     */
    public int getDODPBNFKKEL() {
      return dODPBNFKKEL;
    }

    /**
     * <code>optional uint32 DODPBNFKKEL = 6;</code>
     * @param value the dODPBNFKKEL to set
     * @return this
     */
    public ChessRogueFinishInfo setDODPBNFKKEL(final int value) {
      bitField0_ |= 0x00000004;
      dODPBNFKKEL = value;
      return this;
    }

    /**
     * <code>optional uint32 chess_rogue_main_story_id = 9;</code>
     * @return whether the chessRogueMainStoryId field is set
     */
    public boolean hasChessRogueMainStoryId() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional uint32 chess_rogue_main_story_id = 9;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearChessRogueMainStoryId() {
      bitField0_ &= ~0x00000008;
      chessRogueMainStoryId = 0;
      return this;
    }

    /**
     * <code>optional uint32 chess_rogue_main_story_id = 9;</code>
     * @return the chessRogueMainStoryId
     */
    public int getChessRogueMainStoryId() {
      return chessRogueMainStoryId;
    }

    /**
     * <code>optional uint32 chess_rogue_main_story_id = 9;</code>
     * @param value the chessRogueMainStoryId to set
     * @return this
     */
    public ChessRogueFinishInfo setChessRogueMainStoryId(final int value) {
      bitField0_ |= 0x00000008;
      chessRogueMainStoryId = value;
      return this;
    }

    /**
     * <code>optional uint32 difficulty_level = 11;</code>
     * @return whether the difficultyLevel field is set
     */
    public boolean hasDifficultyLevel() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional uint32 difficulty_level = 11;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearDifficultyLevel() {
      bitField0_ &= ~0x00000010;
      difficultyLevel = 0;
      return this;
    }

    /**
     * <code>optional uint32 difficulty_level = 11;</code>
     * @return the difficultyLevel
     */
    public int getDifficultyLevel() {
      return difficultyLevel;
    }

    /**
     * <code>optional uint32 difficulty_level = 11;</code>
     * @param value the difficultyLevel to set
     * @return this
     */
    public ChessRogueFinishInfo setDifficultyLevel(final int value) {
      bitField0_ |= 0x00000010;
      difficultyLevel = value;
      return this;
    }

    /**
     * <code>optional uint32 OLMBPLAIMLP = 15;</code>
     * @return whether the oLMBPLAIMLP field is set
     */
    public boolean hasOLMBPLAIMLP() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional uint32 OLMBPLAIMLP = 15;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearOLMBPLAIMLP() {
      bitField0_ &= ~0x00000020;
      oLMBPLAIMLP = 0;
      return this;
    }

    /**
     * <code>optional uint32 OLMBPLAIMLP = 15;</code>
     * @return the oLMBPLAIMLP
     */
    public int getOLMBPLAIMLP() {
      return oLMBPLAIMLP;
    }

    /**
     * <code>optional uint32 OLMBPLAIMLP = 15;</code>
     * @param value the oLMBPLAIMLP to set
     * @return this
     */
    public ChessRogueFinishInfo setOLMBPLAIMLP(final int value) {
      bitField0_ |= 0x00000020;
      oLMBPLAIMLP = value;
      return this;
    }

    /**
     * <code>optional uint32 score_id = 468;</code>
     * @return whether the scoreId field is set
     */
    public boolean hasScoreId() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional uint32 score_id = 468;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearScoreId() {
      bitField0_ &= ~0x00000040;
      scoreId = 0;
      return this;
    }

    /**
     * <code>optional uint32 score_id = 468;</code>
     * @return the scoreId
     */
    public int getScoreId() {
      return scoreId;
    }

    /**
     * <code>optional uint32 score_id = 468;</code>
     * @param value the scoreId to set
     * @return this
     */
    public ChessRogueFinishInfo setScoreId(final int value) {
      bitField0_ |= 0x00000040;
      scoreId = value;
      return this;
    }

    /**
     * <code>optional uint32 rogue_sub_mode = 862;</code>
     * @return whether the rogueSubMode field is set
     */
    public boolean hasRogueSubMode() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional uint32 rogue_sub_mode = 862;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearRogueSubMode() {
      bitField0_ &= ~0x00000080;
      rogueSubMode = 0;
      return this;
    }

    /**
     * <code>optional uint32 rogue_sub_mode = 862;</code>
     * @return the rogueSubMode
     */
    public int getRogueSubMode() {
      return rogueSubMode;
    }

    /**
     * <code>optional uint32 rogue_sub_mode = 862;</code>
     * @param value the rogueSubMode to set
     * @return this
     */
    public ChessRogueFinishInfo setRogueSubMode(final int value) {
      bitField0_ |= 0x00000080;
      rogueSubMode = value;
      return this;
    }

    /**
     * <code>optional uint32 BIOHIBDDDFG = 912;</code>
     * @return whether the bIOHIBDDDFG field is set
     */
    public boolean hasBIOHIBDDDFG() {
      return (bitField0_ & 0x00000100) != 0;
    }

    /**
     * <code>optional uint32 BIOHIBDDDFG = 912;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearBIOHIBDDDFG() {
      bitField0_ &= ~0x00000100;
      bIOHIBDDDFG = 0;
      return this;
    }

    /**
     * <code>optional uint32 BIOHIBDDDFG = 912;</code>
     * @return the bIOHIBDDDFG
     */
    public int getBIOHIBDDDFG() {
      return bIOHIBDDDFG;
    }

    /**
     * <code>optional uint32 BIOHIBDDDFG = 912;</code>
     * @param value the bIOHIBDDDFG to set
     * @return this
     */
    public ChessRogueFinishInfo setBIOHIBDDDFG(final int value) {
      bitField0_ |= 0x00000100;
      bIOHIBDDDFG = value;
      return this;
    }

    /**
     * <code>optional uint32 LEBECEFMDJN = 1129;</code>
     * @return whether the lEBECEFMDJN field is set
     */
    public boolean hasLEBECEFMDJN() {
      return (bitField0_ & 0x00000200) != 0;
    }

    /**
     * <code>optional uint32 LEBECEFMDJN = 1129;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearLEBECEFMDJN() {
      bitField0_ &= ~0x00000200;
      lEBECEFMDJN = 0;
      return this;
    }

    /**
     * <code>optional uint32 LEBECEFMDJN = 1129;</code>
     * @return the lEBECEFMDJN
     */
    public int getLEBECEFMDJN() {
      return lEBECEFMDJN;
    }

    /**
     * <code>optional uint32 LEBECEFMDJN = 1129;</code>
     * @param value the lEBECEFMDJN to set
     * @return this
     */
    public ChessRogueFinishInfo setLEBECEFMDJN(final int value) {
      bitField0_ |= 0x00000200;
      lEBECEFMDJN = value;
      return this;
    }

    /**
     * <code>optional uint32 CNCAOLEDBDI = 1705;</code>
     * @return whether the cNCAOLEDBDI field is set
     */
    public boolean hasCNCAOLEDBDI() {
      return (bitField0_ & 0x00000400) != 0;
    }

    /**
     * <code>optional uint32 CNCAOLEDBDI = 1705;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearCNCAOLEDBDI() {
      bitField0_ &= ~0x00000400;
      cNCAOLEDBDI = 0;
      return this;
    }

    /**
     * <code>optional uint32 CNCAOLEDBDI = 1705;</code>
     * @return the cNCAOLEDBDI
     */
    public int getCNCAOLEDBDI() {
      return cNCAOLEDBDI;
    }

    /**
     * <code>optional uint32 CNCAOLEDBDI = 1705;</code>
     * @param value the cNCAOLEDBDI to set
     * @return this
     */
    public ChessRogueFinishInfo setCNCAOLEDBDI(final int value) {
      bitField0_ |= 0x00000400;
      cNCAOLEDBDI = value;
      return this;
    }

    /**
     * <code>optional .ChessRogueQuitReason quit_reason = 14;</code>
     * @return whether the quitReason field is set
     */
    public boolean hasQuitReason() {
      return (bitField0_ & 0x00000800) != 0;
    }

    /**
     * <code>optional .ChessRogueQuitReason quit_reason = 14;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearQuitReason() {
      bitField0_ &= ~0x00000800;
      quitReason = 0;
      return this;
    }

    /**
     * <code>optional .ChessRogueQuitReason quit_reason = 14;</code>
     * @return the quitReason
     */
    public ChessRogueQuitReasonOuterClass.ChessRogueQuitReason getQuitReason() {
      return ChessRogueQuitReasonOuterClass.ChessRogueQuitReason.forNumber(quitReason);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link ChessRogueFinishInfo#getQuitReason()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getQuitReasonValue() {
      return quitReason;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link ChessRogueQuitReasonOuterClass.ChessRogueQuitReason}. Setting an invalid value
     * can cause {@link ChessRogueFinishInfo#getQuitReason()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public ChessRogueFinishInfo setQuitReasonValue(final int value) {
      bitField0_ |= 0x00000800;
      quitReason = value;
      return this;
    }

    /**
     * <code>optional .ChessRogueQuitReason quit_reason = 14;</code>
     * @param value the quitReason to set
     * @return this
     */
    public ChessRogueFinishInfo setQuitReason(
        final ChessRogueQuitReasonOuterClass.ChessRogueQuitReason value) {
      bitField0_ |= 0x00000800;
      quitReason = value.getNumber();
      return this;
    }

    /**
     * <code>optional bool is_finish = 4;</code>
     * @return whether the isFinish field is set
     */
    public boolean hasIsFinish() {
      return (bitField0_ & 0x00001000) != 0;
    }

    /**
     * <code>optional bool is_finish = 4;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearIsFinish() {
      bitField0_ &= ~0x00001000;
      isFinish = false;
      return this;
    }

    /**
     * <code>optional bool is_finish = 4;</code>
     * @return the isFinish
     */
    public boolean getIsFinish() {
      return isFinish;
    }

    /**
     * <code>optional bool is_finish = 4;</code>
     * @param value the isFinish to set
     * @return this
     */
    public ChessRogueFinishInfo setIsFinish(final boolean value) {
      bitField0_ |= 0x00001000;
      isFinish = value;
      return this;
    }

    /**
     * <code>optional .ItemList EPGJCMNBIPJ = 3;</code>
     * @return whether the ePGJCMNBIPJ field is set
     */
    public boolean hasEPGJCMNBIPJ() {
      return (bitField0_ & 0x00002000) != 0;
    }

    /**
     * <code>optional .ItemList EPGJCMNBIPJ = 3;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearEPGJCMNBIPJ() {
      bitField0_ &= ~0x00002000;
      ePGJCMNBIPJ.clear();
      return this;
    }

    /**
     * <code>optional .ItemList EPGJCMNBIPJ = 3;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableEPGJCMNBIPJ()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ItemListOuterClass.ItemList getEPGJCMNBIPJ() {
      return ePGJCMNBIPJ;
    }

    /**
     * <code>optional .ItemList EPGJCMNBIPJ = 3;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ItemListOuterClass.ItemList getMutableEPGJCMNBIPJ() {
      bitField0_ |= 0x00002000;
      return ePGJCMNBIPJ;
    }

    /**
     * <code>optional .ItemList EPGJCMNBIPJ = 3;</code>
     * @param value the ePGJCMNBIPJ to set
     * @return this
     */
    public ChessRogueFinishInfo setEPGJCMNBIPJ(final ItemListOuterClass.ItemList value) {
      bitField0_ |= 0x00002000;
      ePGJCMNBIPJ.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .ChessRogueBuff rogue_buff_info = 7;</code>
     * @return whether the rogueBuffInfo field is set
     */
    public boolean hasRogueBuffInfo() {
      return (bitField0_ & 0x00004000) != 0;
    }

    /**
     * <code>optional .ChessRogueBuff rogue_buff_info = 7;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearRogueBuffInfo() {
      bitField0_ &= ~0x00004000;
      rogueBuffInfo.clear();
      return this;
    }

    /**
     * <code>optional .ChessRogueBuff rogue_buff_info = 7;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRogueBuffInfo()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ChessRogueBuffOuterClass.ChessRogueBuff getRogueBuffInfo() {
      return rogueBuffInfo;
    }

    /**
     * <code>optional .ChessRogueBuff rogue_buff_info = 7;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ChessRogueBuffOuterClass.ChessRogueBuff getMutableRogueBuffInfo() {
      bitField0_ |= 0x00004000;
      return rogueBuffInfo;
    }

    /**
     * <code>optional .ChessRogueBuff rogue_buff_info = 7;</code>
     * @param value the rogueBuffInfo to set
     * @return this
     */
    public ChessRogueFinishInfo setRogueBuffInfo(
        final ChessRogueBuffOuterClass.ChessRogueBuff value) {
      bitField0_ |= 0x00004000;
      rogueBuffInfo.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .LineupInfo rogue_lineup = 10;</code>
     * @return whether the rogueLineup field is set
     */
    public boolean hasRogueLineup() {
      return (bitField0_ & 0x00008000) != 0;
    }

    /**
     * <code>optional .LineupInfo rogue_lineup = 10;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearRogueLineup() {
      bitField0_ &= ~0x00008000;
      rogueLineup.clear();
      return this;
    }

    /**
     * <code>optional .LineupInfo rogue_lineup = 10;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRogueLineup()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public LineupInfoOuterClass.LineupInfo getRogueLineup() {
      return rogueLineup;
    }

    /**
     * <code>optional .LineupInfo rogue_lineup = 10;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public LineupInfoOuterClass.LineupInfo getMutableRogueLineup() {
      bitField0_ |= 0x00008000;
      return rogueLineup;
    }

    /**
     * <code>optional .LineupInfo rogue_lineup = 10;</code>
     * @param value the rogueLineup to set
     * @return this
     */
    public ChessRogueFinishInfo setRogueLineup(final LineupInfoOuterClass.LineupInfo value) {
      bitField0_ |= 0x00008000;
      rogueLineup.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .ChessRogueMiracle game_miracle_info = 12;</code>
     * @return whether the gameMiracleInfo field is set
     */
    public boolean hasGameMiracleInfo() {
      return (bitField0_ & 0x00010000) != 0;
    }

    /**
     * <code>optional .ChessRogueMiracle game_miracle_info = 12;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearGameMiracleInfo() {
      bitField0_ &= ~0x00010000;
      gameMiracleInfo.clear();
      return this;
    }

    /**
     * <code>optional .ChessRogueMiracle game_miracle_info = 12;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGameMiracleInfo()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ChessRogueMiracleOuterClass.ChessRogueMiracle getGameMiracleInfo() {
      return gameMiracleInfo;
    }

    /**
     * <code>optional .ChessRogueMiracle game_miracle_info = 12;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ChessRogueMiracleOuterClass.ChessRogueMiracle getMutableGameMiracleInfo() {
      bitField0_ |= 0x00010000;
      return gameMiracleInfo;
    }

    /**
     * <code>optional .ChessRogueMiracle game_miracle_info = 12;</code>
     * @param value the gameMiracleInfo to set
     * @return this
     */
    public ChessRogueFinishInfo setGameMiracleInfo(
        final ChessRogueMiracleOuterClass.ChessRogueMiracle value) {
      bitField0_ |= 0x00010000;
      gameMiracleInfo.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .JPFECHLHHEN NKGKDMFHGFJ = 1250;</code>
     * @return whether the nKGKDMFHGFJ field is set
     */
    public boolean hasNKGKDMFHGFJ() {
      return (bitField0_ & 0x00020000) != 0;
    }

    /**
     * <code>optional .JPFECHLHHEN NKGKDMFHGFJ = 1250;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearNKGKDMFHGFJ() {
      bitField0_ &= ~0x00020000;
      nKGKDMFHGFJ.clear();
      return this;
    }

    /**
     * <code>optional .JPFECHLHHEN NKGKDMFHGFJ = 1250;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableNKGKDMFHGFJ()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public JPFECHLHHENOuterClass.JPFECHLHHEN getNKGKDMFHGFJ() {
      return nKGKDMFHGFJ;
    }

    /**
     * <code>optional .JPFECHLHHEN NKGKDMFHGFJ = 1250;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public JPFECHLHHENOuterClass.JPFECHLHHEN getMutableNKGKDMFHGFJ() {
      bitField0_ |= 0x00020000;
      return nKGKDMFHGFJ;
    }

    /**
     * <code>optional .JPFECHLHHEN NKGKDMFHGFJ = 1250;</code>
     * @param value the nKGKDMFHGFJ to set
     * @return this
     */
    public ChessRogueFinishInfo setNKGKDMFHGFJ(final JPFECHLHHENOuterClass.JPFECHLHHEN value) {
      bitField0_ |= 0x00020000;
      nKGKDMFHGFJ.copyFrom(value);
      return this;
    }

    /**
     * <code>repeated uint32 HHMFIDKFNNI = 5;</code>
     * @return whether the hHMFIDKFNNI field is set
     */
    public boolean hasHHMFIDKFNNI() {
      return (bitField0_ & 0x00040000) != 0;
    }

    /**
     * <code>repeated uint32 HHMFIDKFNNI = 5;</code>
     * @return this
     */
    public ChessRogueFinishInfo clearHHMFIDKFNNI() {
      bitField0_ &= ~0x00040000;
      hHMFIDKFNNI.clear();
      return this;
    }

    /**
     * <code>repeated uint32 HHMFIDKFNNI = 5;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableHHMFIDKFNNI()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RepeatedInt getHHMFIDKFNNI() {
      return hHMFIDKFNNI;
    }

    /**
     * <code>repeated uint32 HHMFIDKFNNI = 5;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RepeatedInt getMutableHHMFIDKFNNI() {
      bitField0_ |= 0x00040000;
      return hHMFIDKFNNI;
    }

    /**
     * <code>repeated uint32 HHMFIDKFNNI = 5;</code>
     * @param value the hHMFIDKFNNI to add
     * @return this
     */
    public ChessRogueFinishInfo addHHMFIDKFNNI(final int value) {
      bitField0_ |= 0x00040000;
      hHMFIDKFNNI.add(value);
      return this;
    }

    /**
     * <code>repeated uint32 HHMFIDKFNNI = 5;</code>
     * @param values the hHMFIDKFNNI to add
     * @return this
     */
    public ChessRogueFinishInfo addAllHHMFIDKFNNI(final int... values) {
      bitField0_ |= 0x00040000;
      hHMFIDKFNNI.addAll(values);
      return this;
    }

    @Override
    public ChessRogueFinishInfo copyFrom(final ChessRogueFinishInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        endAreaId = other.endAreaId;
        lastLayerId = other.lastLayerId;
        dODPBNFKKEL = other.dODPBNFKKEL;
        chessRogueMainStoryId = other.chessRogueMainStoryId;
        difficultyLevel = other.difficultyLevel;
        oLMBPLAIMLP = other.oLMBPLAIMLP;
        scoreId = other.scoreId;
        rogueSubMode = other.rogueSubMode;
        bIOHIBDDDFG = other.bIOHIBDDDFG;
        lEBECEFMDJN = other.lEBECEFMDJN;
        cNCAOLEDBDI = other.cNCAOLEDBDI;
        quitReason = other.quitReason;
        isFinish = other.isFinish;
        ePGJCMNBIPJ.copyFrom(other.ePGJCMNBIPJ);
        rogueBuffInfo.copyFrom(other.rogueBuffInfo);
        rogueLineup.copyFrom(other.rogueLineup);
        gameMiracleInfo.copyFrom(other.gameMiracleInfo);
        nKGKDMFHGFJ.copyFrom(other.nKGKDMFHGFJ);
        hHMFIDKFNNI.copyFrom(other.hHMFIDKFNNI);
      }
      return this;
    }

    @Override
    public ChessRogueFinishInfo mergeFrom(final ChessRogueFinishInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasEndAreaId()) {
        setEndAreaId(other.endAreaId);
      }
      if (other.hasLastLayerId()) {
        setLastLayerId(other.lastLayerId);
      }
      if (other.hasDODPBNFKKEL()) {
        setDODPBNFKKEL(other.dODPBNFKKEL);
      }
      if (other.hasChessRogueMainStoryId()) {
        setChessRogueMainStoryId(other.chessRogueMainStoryId);
      }
      if (other.hasDifficultyLevel()) {
        setDifficultyLevel(other.difficultyLevel);
      }
      if (other.hasOLMBPLAIMLP()) {
        setOLMBPLAIMLP(other.oLMBPLAIMLP);
      }
      if (other.hasScoreId()) {
        setScoreId(other.scoreId);
      }
      if (other.hasRogueSubMode()) {
        setRogueSubMode(other.rogueSubMode);
      }
      if (other.hasBIOHIBDDDFG()) {
        setBIOHIBDDDFG(other.bIOHIBDDDFG);
      }
      if (other.hasLEBECEFMDJN()) {
        setLEBECEFMDJN(other.lEBECEFMDJN);
      }
      if (other.hasCNCAOLEDBDI()) {
        setCNCAOLEDBDI(other.cNCAOLEDBDI);
      }
      if (other.hasQuitReason()) {
        setQuitReasonValue(other.quitReason);
      }
      if (other.hasIsFinish()) {
        setIsFinish(other.isFinish);
      }
      if (other.hasEPGJCMNBIPJ()) {
        getMutableEPGJCMNBIPJ().mergeFrom(other.ePGJCMNBIPJ);
      }
      if (other.hasRogueBuffInfo()) {
        getMutableRogueBuffInfo().mergeFrom(other.rogueBuffInfo);
      }
      if (other.hasRogueLineup()) {
        getMutableRogueLineup().mergeFrom(other.rogueLineup);
      }
      if (other.hasGameMiracleInfo()) {
        getMutableGameMiracleInfo().mergeFrom(other.gameMiracleInfo);
      }
      if (other.hasNKGKDMFHGFJ()) {
        getMutableNKGKDMFHGFJ().mergeFrom(other.nKGKDMFHGFJ);
      }
      if (other.hasHHMFIDKFNNI()) {
        getMutableHHMFIDKFNNI().addAll(other.hHMFIDKFNNI);
      }
      return this;
    }

    @Override
    public ChessRogueFinishInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      endAreaId = 0;
      lastLayerId = 0;
      dODPBNFKKEL = 0;
      chessRogueMainStoryId = 0;
      difficultyLevel = 0;
      oLMBPLAIMLP = 0;
      scoreId = 0;
      rogueSubMode = 0;
      bIOHIBDDDFG = 0;
      lEBECEFMDJN = 0;
      cNCAOLEDBDI = 0;
      quitReason = 0;
      isFinish = false;
      ePGJCMNBIPJ.clear();
      rogueBuffInfo.clear();
      rogueLineup.clear();
      gameMiracleInfo.clear();
      nKGKDMFHGFJ.clear();
      hHMFIDKFNNI.clear();
      return this;
    }

    @Override
    public ChessRogueFinishInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      ePGJCMNBIPJ.clearQuick();
      rogueBuffInfo.clearQuick();
      rogueLineup.clearQuick();
      gameMiracleInfo.clearQuick();
      nKGKDMFHGFJ.clearQuick();
      hHMFIDKFNNI.clear();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof ChessRogueFinishInfo)) {
        return false;
      }
      ChessRogueFinishInfo other = (ChessRogueFinishInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasEndAreaId() || endAreaId == other.endAreaId)
        && (!hasLastLayerId() || lastLayerId == other.lastLayerId)
        && (!hasDODPBNFKKEL() || dODPBNFKKEL == other.dODPBNFKKEL)
        && (!hasChessRogueMainStoryId() || chessRogueMainStoryId == other.chessRogueMainStoryId)
        && (!hasDifficultyLevel() || difficultyLevel == other.difficultyLevel)
        && (!hasOLMBPLAIMLP() || oLMBPLAIMLP == other.oLMBPLAIMLP)
        && (!hasScoreId() || scoreId == other.scoreId)
        && (!hasRogueSubMode() || rogueSubMode == other.rogueSubMode)
        && (!hasBIOHIBDDDFG() || bIOHIBDDDFG == other.bIOHIBDDDFG)
        && (!hasLEBECEFMDJN() || lEBECEFMDJN == other.lEBECEFMDJN)
        && (!hasCNCAOLEDBDI() || cNCAOLEDBDI == other.cNCAOLEDBDI)
        && (!hasQuitReason() || quitReason == other.quitReason)
        && (!hasIsFinish() || isFinish == other.isFinish)
        && (!hasEPGJCMNBIPJ() || ePGJCMNBIPJ.equals(other.ePGJCMNBIPJ))
        && (!hasRogueBuffInfo() || rogueBuffInfo.equals(other.rogueBuffInfo))
        && (!hasRogueLineup() || rogueLineup.equals(other.rogueLineup))
        && (!hasGameMiracleInfo() || gameMiracleInfo.equals(other.gameMiracleInfo))
        && (!hasNKGKDMFHGFJ() || nKGKDMFHGFJ.equals(other.nKGKDMFHGFJ))
        && (!hasHHMFIDKFNNI() || hHMFIDKFNNI.equals(other.hHMFIDKFNNI));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 8);
        output.writeUInt32NoTag(endAreaId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 16);
        output.writeUInt32NoTag(lastLayerId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 48);
        output.writeUInt32NoTag(dODPBNFKKEL);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 72);
        output.writeUInt32NoTag(chessRogueMainStoryId);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 88);
        output.writeUInt32NoTag(difficultyLevel);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 120);
        output.writeUInt32NoTag(oLMBPLAIMLP);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawLittleEndian16((short) 7584);
        output.writeUInt32NoTag(scoreId);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawLittleEndian16((short) 13808);
        output.writeUInt32NoTag(rogueSubMode);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeRawLittleEndian16((short) 14720);
        output.writeUInt32NoTag(bIOHIBDDDFG);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeRawLittleEndian16((short) 18120);
        output.writeUInt32NoTag(lEBECEFMDJN);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeRawLittleEndian16((short) 27336);
        output.writeUInt32NoTag(cNCAOLEDBDI);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeRawByte((byte) 112);
        output.writeEnumNoTag(quitReason);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeRawByte((byte) 32);
        output.writeBoolNoTag(isFinish);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        output.writeRawByte((byte) 26);
        output.writeMessageNoTag(ePGJCMNBIPJ);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        output.writeRawByte((byte) 58);
        output.writeMessageNoTag(rogueBuffInfo);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        output.writeRawByte((byte) 82);
        output.writeMessageNoTag(rogueLineup);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        output.writeRawByte((byte) 98);
        output.writeMessageNoTag(gameMiracleInfo);
      }
      if ((bitField0_ & 0x00020000) != 0) {
        output.writeRawLittleEndian16((short) 20114);
        output.writeMessageNoTag(nKGKDMFHGFJ);
      }
      if ((bitField0_ & 0x00040000) != 0) {
        for (int i = 0; i < hHMFIDKFNNI.length(); i++) {
          output.writeRawByte((byte) 40);
          output.writeUInt32NoTag(hHMFIDKFNNI.array()[i]);
        }
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(endAreaId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(lastLayerId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(dODPBNFKKEL);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(chessRogueMainStoryId);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(difficultyLevel);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeUInt32SizeNoTag(oLMBPLAIMLP);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 2 + ProtoSink.computeUInt32SizeNoTag(scoreId);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 2 + ProtoSink.computeUInt32SizeNoTag(rogueSubMode);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        size += 2 + ProtoSink.computeUInt32SizeNoTag(bIOHIBDDDFG);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        size += 2 + ProtoSink.computeUInt32SizeNoTag(lEBECEFMDJN);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        size += 2 + ProtoSink.computeUInt32SizeNoTag(cNCAOLEDBDI);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        size += 1 + ProtoSink.computeEnumSizeNoTag(quitReason);
      }
      if ((bitField0_ & 0x00001000) != 0) {
        size += 2;
      }
      if ((bitField0_ & 0x00002000) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(ePGJCMNBIPJ);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(rogueBuffInfo);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(rogueLineup);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(gameMiracleInfo);
      }
      if ((bitField0_ & 0x00020000) != 0) {
        size += 2 + ProtoSink.computeMessageSizeNoTag(nKGKDMFHGFJ);
      }
      if ((bitField0_ & 0x00040000) != 0) {
        size += (1 * hHMFIDKFNNI.length()) + ProtoSink.computeRepeatedUInt32SizeNoTag(hHMFIDKFNNI);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public ChessRogueFinishInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 8: {
            // endAreaId
            endAreaId = input.readUInt32();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 16) {
              break;
            }
          }
          case 16: {
            // lastLayerId
            lastLayerId = input.readUInt32();
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 48) {
              break;
            }
          }
          case 48: {
            // dODPBNFKKEL
            dODPBNFKKEL = input.readUInt32();
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 72) {
              break;
            }
          }
          case 72: {
            // chessRogueMainStoryId
            chessRogueMainStoryId = input.readUInt32();
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 88) {
              break;
            }
          }
          case 88: {
            // difficultyLevel
            difficultyLevel = input.readUInt32();
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 120) {
              break;
            }
          }
          case 120: {
            // oLMBPLAIMLP
            oLMBPLAIMLP = input.readUInt32();
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 3744) {
              break;
            }
          }
          case 3744: {
            // scoreId
            scoreId = input.readUInt32();
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 6896) {
              break;
            }
          }
          case 6896: {
            // rogueSubMode
            rogueSubMode = input.readUInt32();
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 7296) {
              break;
            }
          }
          case 7296: {
            // bIOHIBDDDFG
            bIOHIBDDDFG = input.readUInt32();
            bitField0_ |= 0x00000100;
            tag = input.readTag();
            if (tag != 9032) {
              break;
            }
          }
          case 9032: {
            // lEBECEFMDJN
            lEBECEFMDJN = input.readUInt32();
            bitField0_ |= 0x00000200;
            tag = input.readTag();
            if (tag != 13640) {
              break;
            }
          }
          case 13640: {
            // cNCAOLEDBDI
            cNCAOLEDBDI = input.readUInt32();
            bitField0_ |= 0x00000400;
            tag = input.readTag();
            if (tag != 112) {
              break;
            }
          }
          case 112: {
            // quitReason
            final int value = input.readInt32();
            if (ChessRogueQuitReasonOuterClass.ChessRogueQuitReason.forNumber(value) != null) {
              quitReason = value;
              bitField0_ |= 0x00000800;
            }
            tag = input.readTag();
            if (tag != 32) {
              break;
            }
          }
          case 32: {
            // isFinish
            isFinish = input.readBool();
            bitField0_ |= 0x00001000;
            tag = input.readTag();
            if (tag != 26) {
              break;
            }
          }
          case 26: {
            // ePGJCMNBIPJ
            input.readMessage(ePGJCMNBIPJ);
            bitField0_ |= 0x00002000;
            tag = input.readTag();
            if (tag != 58) {
              break;
            }
          }
          case 58: {
            // rogueBuffInfo
            input.readMessage(rogueBuffInfo);
            bitField0_ |= 0x00004000;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // rogueLineup
            input.readMessage(rogueLineup);
            bitField0_ |= 0x00008000;
            tag = input.readTag();
            if (tag != 98) {
              break;
            }
          }
          case 98: {
            // gameMiracleInfo
            input.readMessage(gameMiracleInfo);
            bitField0_ |= 0x00010000;
            tag = input.readTag();
            if (tag != 10002) {
              break;
            }
          }
          case 10002: {
            // nKGKDMFHGFJ
            input.readMessage(nKGKDMFHGFJ);
            bitField0_ |= 0x00020000;
            tag = input.readTag();
            if (tag != 42) {
              break;
            }
          }
          case 42: {
            // hHMFIDKFNNI [packed=true]
            input.readPackedUInt32(hHMFIDKFNNI, tag);
            bitField0_ |= 0x00040000;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
          case 40: {
            // hHMFIDKFNNI [packed=false]
            tag = input.readRepeatedUInt32(hHMFIDKFNNI, tag);
            bitField0_ |= 0x00040000;
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeUInt32(FieldNames.endAreaId, endAreaId);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeUInt32(FieldNames.lastLayerId, lastLayerId);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeUInt32(FieldNames.dODPBNFKKEL, dODPBNFKKEL);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeUInt32(FieldNames.chessRogueMainStoryId, chessRogueMainStoryId);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeUInt32(FieldNames.difficultyLevel, difficultyLevel);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeUInt32(FieldNames.oLMBPLAIMLP, oLMBPLAIMLP);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeUInt32(FieldNames.scoreId, scoreId);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeUInt32(FieldNames.rogueSubMode, rogueSubMode);
      }
      if ((bitField0_ & 0x00000100) != 0) {
        output.writeUInt32(FieldNames.bIOHIBDDDFG, bIOHIBDDDFG);
      }
      if ((bitField0_ & 0x00000200) != 0) {
        output.writeUInt32(FieldNames.lEBECEFMDJN, lEBECEFMDJN);
      }
      if ((bitField0_ & 0x00000400) != 0) {
        output.writeUInt32(FieldNames.cNCAOLEDBDI, cNCAOLEDBDI);
      }
      if ((bitField0_ & 0x00000800) != 0) {
        output.writeEnum(FieldNames.quitReason, quitReason, ChessRogueQuitReasonOuterClass.ChessRogueQuitReason.converter());
      }
      if ((bitField0_ & 0x00001000) != 0) {
        output.writeBool(FieldNames.isFinish, isFinish);
      }
      if ((bitField0_ & 0x00002000) != 0) {
        output.writeMessage(FieldNames.ePGJCMNBIPJ, ePGJCMNBIPJ);
      }
      if ((bitField0_ & 0x00004000) != 0) {
        output.writeMessage(FieldNames.rogueBuffInfo, rogueBuffInfo);
      }
      if ((bitField0_ & 0x00008000) != 0) {
        output.writeMessage(FieldNames.rogueLineup, rogueLineup);
      }
      if ((bitField0_ & 0x00010000) != 0) {
        output.writeMessage(FieldNames.gameMiracleInfo, gameMiracleInfo);
      }
      if ((bitField0_ & 0x00020000) != 0) {
        output.writeMessage(FieldNames.nKGKDMFHGFJ, nKGKDMFHGFJ);
      }
      if ((bitField0_ & 0x00040000) != 0) {
        output.writeRepeatedUInt32(FieldNames.hHMFIDKFNNI, hHMFIDKFNNI);
      }
      output.endObject();
    }

    @Override
    public ChessRogueFinishInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1091637059:
          case 9821865: {
            if (input.isAtField(FieldNames.endAreaId)) {
              if (!input.trySkipNullValue()) {
                endAreaId = input.readUInt32();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1842208470:
          case -713460142: {
            if (input.isAtField(FieldNames.lastLayerId)) {
              if (!input.trySkipNullValue()) {
                lastLayerId = input.readUInt32();
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -194522038: {
            if (input.isAtField(FieldNames.dODPBNFKKEL)) {
              if (!input.trySkipNullValue()) {
                dODPBNFKKEL = input.readUInt32();
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -2023751203:
          case 1610113799: {
            if (input.isAtField(FieldNames.chessRogueMainStoryId)) {
              if (!input.trySkipNullValue()) {
                chessRogueMainStoryId = input.readUInt32();
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1034989431:
          case -1469972992: {
            if (input.isAtField(FieldNames.difficultyLevel)) {
              if (!input.trySkipNullValue()) {
                difficultyLevel = input.readUInt32();
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -430122885: {
            if (input.isAtField(FieldNames.oLMBPLAIMLP)) {
              if (!input.trySkipNullValue()) {
                oLMBPLAIMLP = input.readUInt32();
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1924000589:
          case -485502488: {
            if (input.isAtField(FieldNames.scoreId)) {
              if (!input.trySkipNullValue()) {
                scoreId = input.readUInt32();
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -121307959:
          case 251315463: {
            if (input.isAtField(FieldNames.rogueSubMode)) {
              if (!input.trySkipNullValue()) {
                rogueSubMode = input.readUInt32();
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1904269908: {
            if (input.isAtField(FieldNames.bIOHIBDDDFG)) {
              if (!input.trySkipNullValue()) {
                bIOHIBDDDFG = input.readUInt32();
                bitField0_ |= 0x00000100;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1761304509: {
            if (input.isAtField(FieldNames.lEBECEFMDJN)) {
              if (!input.trySkipNullValue()) {
                lEBECEFMDJN = input.readUInt32();
                bitField0_ |= 0x00000200;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1828292962: {
            if (input.isAtField(FieldNames.cNCAOLEDBDI)) {
              if (!input.trySkipNullValue()) {
                cNCAOLEDBDI = input.readUInt32();
                bitField0_ |= 0x00000400;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1123391117:
          case -1437399500: {
            if (input.isAtField(FieldNames.quitReason)) {
              if (!input.trySkipNullValue()) {
                final ChessRogueQuitReasonOuterClass.ChessRogueQuitReason value = input.readEnum(ChessRogueQuitReasonOuterClass.ChessRogueQuitReason.converter());
                if (value != null) {
                  quitReason = value.getNumber();
                  bitField0_ |= 0x00000800;
                } else {
                  input.skipUnknownEnumValue();
                }
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -600408483:
          case -810403512: {
            if (input.isAtField(FieldNames.isFinish)) {
              if (!input.trySkipNullValue()) {
                isFinish = input.readBool();
                bitField0_ |= 0x00001000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -21350121: {
            if (input.isAtField(FieldNames.ePGJCMNBIPJ)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(ePGJCMNBIPJ);
                bitField0_ |= 0x00002000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 1107898267:
          case -694847243: {
            if (input.isAtField(FieldNames.rogueBuffInfo)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(rogueBuffInfo);
                bitField0_ |= 0x00004000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1046302711:
          case 1688577940: {
            if (input.isAtField(FieldNames.rogueLineup)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(rogueLineup);
                bitField0_ |= 0x00008000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -471061139:
          case 1278717673: {
            if (input.isAtField(FieldNames.gameMiracleInfo)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(gameMiracleInfo);
                bitField0_ |= 0x00010000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 296659423: {
            if (input.isAtField(FieldNames.nKGKDMFHGFJ)) {
              if (!input.trySkipNullValue()) {
                input.readMessage(nKGKDMFHGFJ);
                bitField0_ |= 0x00020000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 588517978: {
            if (input.isAtField(FieldNames.hHMFIDKFNNI)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedUInt32(hHMFIDKFNNI);
                bitField0_ |= 0x00040000;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public ChessRogueFinishInfo clone() {
      return new ChessRogueFinishInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static ChessRogueFinishInfo parseFrom(final byte[] data) throws
        InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new ChessRogueFinishInfo(), data).checkInitialized();
    }

    public static ChessRogueFinishInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ChessRogueFinishInfo(), input).checkInitialized();
    }

    public static ChessRogueFinishInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new ChessRogueFinishInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating ChessRogueFinishInfo messages
     */
    public static MessageFactory<ChessRogueFinishInfo> getFactory() {
      return ChessRogueFinishInfoFactory.INSTANCE;
    }

    private enum ChessRogueFinishInfoFactory implements MessageFactory<ChessRogueFinishInfo> {
      INSTANCE;

      @Override
      public ChessRogueFinishInfo create() {
        return ChessRogueFinishInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName endAreaId = FieldName.forField("endAreaId", "end_area_id");

      static final FieldName lastLayerId = FieldName.forField("lastLayerId", "last_layer_id");

      static final FieldName dODPBNFKKEL = FieldName.forField("DODPBNFKKEL");

      static final FieldName chessRogueMainStoryId = FieldName.forField("chessRogueMainStoryId", "chess_rogue_main_story_id");

      static final FieldName difficultyLevel = FieldName.forField("difficultyLevel", "difficulty_level");

      static final FieldName oLMBPLAIMLP = FieldName.forField("OLMBPLAIMLP");

      static final FieldName scoreId = FieldName.forField("scoreId", "score_id");

      static final FieldName rogueSubMode = FieldName.forField("rogueSubMode", "rogue_sub_mode");

      static final FieldName bIOHIBDDDFG = FieldName.forField("BIOHIBDDDFG");

      static final FieldName lEBECEFMDJN = FieldName.forField("LEBECEFMDJN");

      static final FieldName cNCAOLEDBDI = FieldName.forField("CNCAOLEDBDI");

      static final FieldName quitReason = FieldName.forField("quitReason", "quit_reason");

      static final FieldName isFinish = FieldName.forField("isFinish", "is_finish");

      static final FieldName ePGJCMNBIPJ = FieldName.forField("EPGJCMNBIPJ");

      static final FieldName rogueBuffInfo = FieldName.forField("rogueBuffInfo", "rogue_buff_info");

      static final FieldName rogueLineup = FieldName.forField("rogueLineup", "rogue_lineup");

      static final FieldName gameMiracleInfo = FieldName.forField("gameMiracleInfo", "game_miracle_info");

      static final FieldName nKGKDMFHGFJ = FieldName.forField("NKGKDMFHGFJ");

      static final FieldName hHMFIDKFNNI = FieldName.forField("HHMFIDKFNNI");
    }
  }
}
