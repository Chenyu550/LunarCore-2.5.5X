// Code generated by protocol buffer compiler. Do not edit!
package emu.lunarcore.proto;

import java.io.IOException;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;

public final class RogueGameInfoOuterClass {
  /**
   * Protobuf type {@code RogueGameInfo}
   */
  public static final class RogueGameInfo extends ProtoMessage<RogueGameInfo> implements Cloneable {
    private static final long serialVersionUID = 0L;

    /**
     * <code>optional .ChessRogueBuffInfo rogue_buff_info = 2;</code>
     */
    private final ChessRogueBuffInfoOuterClass.ChessRogueBuffInfo rogueBuffInfo = ChessRogueBuffInfoOuterClass.ChessRogueBuffInfo.newInstance();

    /**
     * <code>optional .RogueTournFormulaInfo rogue_tourn_formula_info = 7;</code>
     */
    private final RogueTournFormulaInfoOuterClass.RogueTournFormulaInfo rogueTournFormulaInfo = RogueTournFormulaInfoOuterClass.RogueTournFormulaInfo.newInstance();

    /**
     * <code>optional .ChessRogueMiracleInfo game_miracle_info = 10;</code>
     */
    private final ChessRogueMiracleInfoOuterClass.ChessRogueMiracleInfo gameMiracleInfo = ChessRogueMiracleInfoOuterClass.ChessRogueMiracleInfo.newInstance();

    /**
     * <code>optional .RogueDifficultyLevelInfo rogue_difficulty_info = 11;</code>
     */
    private final RogueDifficultyLevelInfoOuterClass.RogueDifficultyLevelInfo rogueDifficultyInfo = RogueDifficultyLevelInfoOuterClass.RogueDifficultyLevelInfo.newInstance();

    /**
     * <code>optional .RogueTournVirtualItem rogue_lineup_info = 12;</code>
     */
    private final RogueTournVirtualItemOuterClass.RogueTournVirtualItem rogueLineupInfo = RogueTournVirtualItemOuterClass.RogueTournVirtualItem.newInstance();

    /**
     * <code>optional .ChessRogueGameAeonInfo rogue_aeon_info = 13;</code>
     */
    private final ChessRogueGameAeonInfoOuterClass.ChessRogueGameAeonInfo rogueAeonInfo = ChessRogueGameAeonInfoOuterClass.ChessRogueGameAeonInfo.newInstance();

    /**
     * <code>optional .KeywordUnlockValue keyword_unlock_value = 14;</code>
     */
    private final KeywordUnlockValueOuterClass.KeywordUnlockValue keywordUnlockValue = KeywordUnlockValueOuterClass.KeywordUnlockValue.newInstance();

    /**
     * <code>optional .RogueGameItemValue game_item_value = 15;</code>
     */
    private final RogueGameItemValueOuterClass.RogueGameItemValue gameItemValue = RogueGameItemValueOuterClass.RogueGameItemValue.newInstance();

    private RogueGameInfo() {
    }

    /**
     * @return a new empty instance of {@code RogueGameInfo}
     */
    public static RogueGameInfo newInstance() {
      return new RogueGameInfo();
    }

    public boolean hasACNDNONOJPJ() {
      return (((bitField0_ & 0x000000ff)) != 0);
    }

    public RogueGameInfo clearACNDNONOJPJ() {
      if (hasACNDNONOJPJ()) {
        clearRogueBuffInfo();
        clearRogueTournFormulaInfo();
        clearGameMiracleInfo();
        clearRogueDifficultyInfo();
        clearRogueLineupInfo();
        clearRogueAeonInfo();
        clearKeywordUnlockValue();
        clearGameItemValue();
      }
      return this;
    }

    private void clearACNDNONOJPJOtherRogueBuffInfo() {
      if ((((bitField0_ & 0x000000fe)) != 0)) {
        clearRogueTournFormulaInfo();
        clearGameMiracleInfo();
        clearRogueDifficultyInfo();
        clearRogueLineupInfo();
        clearRogueAeonInfo();
        clearKeywordUnlockValue();
        clearGameItemValue();
      }
    }

    private void clearACNDNONOJPJOtherRogueTournFormulaInfo() {
      if ((((bitField0_ & 0x000000fd)) != 0)) {
        clearRogueBuffInfo();
        clearGameMiracleInfo();
        clearRogueDifficultyInfo();
        clearRogueLineupInfo();
        clearRogueAeonInfo();
        clearKeywordUnlockValue();
        clearGameItemValue();
      }
    }

    private void clearACNDNONOJPJOtherGameMiracleInfo() {
      if ((((bitField0_ & 0x000000fb)) != 0)) {
        clearRogueBuffInfo();
        clearRogueTournFormulaInfo();
        clearRogueDifficultyInfo();
        clearRogueLineupInfo();
        clearRogueAeonInfo();
        clearKeywordUnlockValue();
        clearGameItemValue();
      }
    }

    private void clearACNDNONOJPJOtherRogueDifficultyInfo() {
      if ((((bitField0_ & 0x000000f7)) != 0)) {
        clearRogueBuffInfo();
        clearRogueTournFormulaInfo();
        clearGameMiracleInfo();
        clearRogueLineupInfo();
        clearRogueAeonInfo();
        clearKeywordUnlockValue();
        clearGameItemValue();
      }
    }

    private void clearACNDNONOJPJOtherRogueLineupInfo() {
      if ((((bitField0_ & 0x000000ef)) != 0)) {
        clearRogueBuffInfo();
        clearRogueTournFormulaInfo();
        clearGameMiracleInfo();
        clearRogueDifficultyInfo();
        clearRogueAeonInfo();
        clearKeywordUnlockValue();
        clearGameItemValue();
      }
    }

    private void clearACNDNONOJPJOtherRogueAeonInfo() {
      if ((((bitField0_ & 0x000000df)) != 0)) {
        clearRogueBuffInfo();
        clearRogueTournFormulaInfo();
        clearGameMiracleInfo();
        clearRogueDifficultyInfo();
        clearRogueLineupInfo();
        clearKeywordUnlockValue();
        clearGameItemValue();
      }
    }

    private void clearACNDNONOJPJOtherKeywordUnlockValue() {
      if ((((bitField0_ & 0x000000bf)) != 0)) {
        clearRogueBuffInfo();
        clearRogueTournFormulaInfo();
        clearGameMiracleInfo();
        clearRogueDifficultyInfo();
        clearRogueLineupInfo();
        clearRogueAeonInfo();
        clearGameItemValue();
      }
    }

    private void clearACNDNONOJPJOtherGameItemValue() {
      if ((((bitField0_ & 0x0000007f)) != 0)) {
        clearRogueBuffInfo();
        clearRogueTournFormulaInfo();
        clearGameMiracleInfo();
        clearRogueDifficultyInfo();
        clearRogueLineupInfo();
        clearRogueAeonInfo();
        clearKeywordUnlockValue();
      }
    }

    /**
     * <code>optional .ChessRogueBuffInfo rogue_buff_info = 2;</code>
     * @return whether the rogueBuffInfo field is set
     */
    public boolean hasRogueBuffInfo() {
      return (bitField0_ & 0x00000001) != 0;
    }

    /**
     * <code>optional .ChessRogueBuffInfo rogue_buff_info = 2;</code>
     * @return this
     */
    public RogueGameInfo clearRogueBuffInfo() {
      bitField0_ &= ~0x00000001;
      rogueBuffInfo.clear();
      return this;
    }

    /**
     * <code>optional .ChessRogueBuffInfo rogue_buff_info = 2;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRogueBuffInfo()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ChessRogueBuffInfoOuterClass.ChessRogueBuffInfo getRogueBuffInfo() {
      return rogueBuffInfo;
    }

    /**
     * <code>optional .ChessRogueBuffInfo rogue_buff_info = 2;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ChessRogueBuffInfoOuterClass.ChessRogueBuffInfo getMutableRogueBuffInfo() {
      clearACNDNONOJPJOtherRogueBuffInfo();
      bitField0_ |= 0x00000001;
      return rogueBuffInfo;
    }

    /**
     * <code>optional .ChessRogueBuffInfo rogue_buff_info = 2;</code>
     * @param value the rogueBuffInfo to set
     * @return this
     */
    public RogueGameInfo setRogueBuffInfo(
        final ChessRogueBuffInfoOuterClass.ChessRogueBuffInfo value) {
      clearACNDNONOJPJOtherRogueBuffInfo();
      bitField0_ |= 0x00000001;
      rogueBuffInfo.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .RogueTournFormulaInfo rogue_tourn_formula_info = 7;</code>
     * @return whether the rogueTournFormulaInfo field is set
     */
    public boolean hasRogueTournFormulaInfo() {
      return (bitField0_ & 0x00000002) != 0;
    }

    /**
     * <code>optional .RogueTournFormulaInfo rogue_tourn_formula_info = 7;</code>
     * @return this
     */
    public RogueGameInfo clearRogueTournFormulaInfo() {
      bitField0_ &= ~0x00000002;
      rogueTournFormulaInfo.clear();
      return this;
    }

    /**
     * <code>optional .RogueTournFormulaInfo rogue_tourn_formula_info = 7;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRogueTournFormulaInfo()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RogueTournFormulaInfoOuterClass.RogueTournFormulaInfo getRogueTournFormulaInfo() {
      return rogueTournFormulaInfo;
    }

    /**
     * <code>optional .RogueTournFormulaInfo rogue_tourn_formula_info = 7;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RogueTournFormulaInfoOuterClass.RogueTournFormulaInfo getMutableRogueTournFormulaInfo() {
      clearACNDNONOJPJOtherRogueTournFormulaInfo();
      bitField0_ |= 0x00000002;
      return rogueTournFormulaInfo;
    }

    /**
     * <code>optional .RogueTournFormulaInfo rogue_tourn_formula_info = 7;</code>
     * @param value the rogueTournFormulaInfo to set
     * @return this
     */
    public RogueGameInfo setRogueTournFormulaInfo(
        final RogueTournFormulaInfoOuterClass.RogueTournFormulaInfo value) {
      clearACNDNONOJPJOtherRogueTournFormulaInfo();
      bitField0_ |= 0x00000002;
      rogueTournFormulaInfo.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .ChessRogueMiracleInfo game_miracle_info = 10;</code>
     * @return whether the gameMiracleInfo field is set
     */
    public boolean hasGameMiracleInfo() {
      return (bitField0_ & 0x00000004) != 0;
    }

    /**
     * <code>optional .ChessRogueMiracleInfo game_miracle_info = 10;</code>
     * @return this
     */
    public RogueGameInfo clearGameMiracleInfo() {
      bitField0_ &= ~0x00000004;
      gameMiracleInfo.clear();
      return this;
    }

    /**
     * <code>optional .ChessRogueMiracleInfo game_miracle_info = 10;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGameMiracleInfo()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ChessRogueMiracleInfoOuterClass.ChessRogueMiracleInfo getGameMiracleInfo() {
      return gameMiracleInfo;
    }

    /**
     * <code>optional .ChessRogueMiracleInfo game_miracle_info = 10;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ChessRogueMiracleInfoOuterClass.ChessRogueMiracleInfo getMutableGameMiracleInfo() {
      clearACNDNONOJPJOtherGameMiracleInfo();
      bitField0_ |= 0x00000004;
      return gameMiracleInfo;
    }

    /**
     * <code>optional .ChessRogueMiracleInfo game_miracle_info = 10;</code>
     * @param value the gameMiracleInfo to set
     * @return this
     */
    public RogueGameInfo setGameMiracleInfo(
        final ChessRogueMiracleInfoOuterClass.ChessRogueMiracleInfo value) {
      clearACNDNONOJPJOtherGameMiracleInfo();
      bitField0_ |= 0x00000004;
      gameMiracleInfo.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .RogueDifficultyLevelInfo rogue_difficulty_info = 11;</code>
     * @return whether the rogueDifficultyInfo field is set
     */
    public boolean hasRogueDifficultyInfo() {
      return (bitField0_ & 0x00000008) != 0;
    }

    /**
     * <code>optional .RogueDifficultyLevelInfo rogue_difficulty_info = 11;</code>
     * @return this
     */
    public RogueGameInfo clearRogueDifficultyInfo() {
      bitField0_ &= ~0x00000008;
      rogueDifficultyInfo.clear();
      return this;
    }

    /**
     * <code>optional .RogueDifficultyLevelInfo rogue_difficulty_info = 11;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRogueDifficultyInfo()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RogueDifficultyLevelInfoOuterClass.RogueDifficultyLevelInfo getRogueDifficultyInfo() {
      return rogueDifficultyInfo;
    }

    /**
     * <code>optional .RogueDifficultyLevelInfo rogue_difficulty_info = 11;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RogueDifficultyLevelInfoOuterClass.RogueDifficultyLevelInfo getMutableRogueDifficultyInfo(
        ) {
      clearACNDNONOJPJOtherRogueDifficultyInfo();
      bitField0_ |= 0x00000008;
      return rogueDifficultyInfo;
    }

    /**
     * <code>optional .RogueDifficultyLevelInfo rogue_difficulty_info = 11;</code>
     * @param value the rogueDifficultyInfo to set
     * @return this
     */
    public RogueGameInfo setRogueDifficultyInfo(
        final RogueDifficultyLevelInfoOuterClass.RogueDifficultyLevelInfo value) {
      clearACNDNONOJPJOtherRogueDifficultyInfo();
      bitField0_ |= 0x00000008;
      rogueDifficultyInfo.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .RogueTournVirtualItem rogue_lineup_info = 12;</code>
     * @return whether the rogueLineupInfo field is set
     */
    public boolean hasRogueLineupInfo() {
      return (bitField0_ & 0x00000010) != 0;
    }

    /**
     * <code>optional .RogueTournVirtualItem rogue_lineup_info = 12;</code>
     * @return this
     */
    public RogueGameInfo clearRogueLineupInfo() {
      bitField0_ &= ~0x00000010;
      rogueLineupInfo.clear();
      return this;
    }

    /**
     * <code>optional .RogueTournVirtualItem rogue_lineup_info = 12;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRogueLineupInfo()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RogueTournVirtualItemOuterClass.RogueTournVirtualItem getRogueLineupInfo() {
      return rogueLineupInfo;
    }

    /**
     * <code>optional .RogueTournVirtualItem rogue_lineup_info = 12;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RogueTournVirtualItemOuterClass.RogueTournVirtualItem getMutableRogueLineupInfo() {
      clearACNDNONOJPJOtherRogueLineupInfo();
      bitField0_ |= 0x00000010;
      return rogueLineupInfo;
    }

    /**
     * <code>optional .RogueTournVirtualItem rogue_lineup_info = 12;</code>
     * @param value the rogueLineupInfo to set
     * @return this
     */
    public RogueGameInfo setRogueLineupInfo(
        final RogueTournVirtualItemOuterClass.RogueTournVirtualItem value) {
      clearACNDNONOJPJOtherRogueLineupInfo();
      bitField0_ |= 0x00000010;
      rogueLineupInfo.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .ChessRogueGameAeonInfo rogue_aeon_info = 13;</code>
     * @return whether the rogueAeonInfo field is set
     */
    public boolean hasRogueAeonInfo() {
      return (bitField0_ & 0x00000020) != 0;
    }

    /**
     * <code>optional .ChessRogueGameAeonInfo rogue_aeon_info = 13;</code>
     * @return this
     */
    public RogueGameInfo clearRogueAeonInfo() {
      bitField0_ &= ~0x00000020;
      rogueAeonInfo.clear();
      return this;
    }

    /**
     * <code>optional .ChessRogueGameAeonInfo rogue_aeon_info = 13;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableRogueAeonInfo()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public ChessRogueGameAeonInfoOuterClass.ChessRogueGameAeonInfo getRogueAeonInfo() {
      return rogueAeonInfo;
    }

    /**
     * <code>optional .ChessRogueGameAeonInfo rogue_aeon_info = 13;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public ChessRogueGameAeonInfoOuterClass.ChessRogueGameAeonInfo getMutableRogueAeonInfo() {
      clearACNDNONOJPJOtherRogueAeonInfo();
      bitField0_ |= 0x00000020;
      return rogueAeonInfo;
    }

    /**
     * <code>optional .ChessRogueGameAeonInfo rogue_aeon_info = 13;</code>
     * @param value the rogueAeonInfo to set
     * @return this
     */
    public RogueGameInfo setRogueAeonInfo(
        final ChessRogueGameAeonInfoOuterClass.ChessRogueGameAeonInfo value) {
      clearACNDNONOJPJOtherRogueAeonInfo();
      bitField0_ |= 0x00000020;
      rogueAeonInfo.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .KeywordUnlockValue keyword_unlock_value = 14;</code>
     * @return whether the keywordUnlockValue field is set
     */
    public boolean hasKeywordUnlockValue() {
      return (bitField0_ & 0x00000040) != 0;
    }

    /**
     * <code>optional .KeywordUnlockValue keyword_unlock_value = 14;</code>
     * @return this
     */
    public RogueGameInfo clearKeywordUnlockValue() {
      bitField0_ &= ~0x00000040;
      keywordUnlockValue.clear();
      return this;
    }

    /**
     * <code>optional .KeywordUnlockValue keyword_unlock_value = 14;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableKeywordUnlockValue()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public KeywordUnlockValueOuterClass.KeywordUnlockValue getKeywordUnlockValue() {
      return keywordUnlockValue;
    }

    /**
     * <code>optional .KeywordUnlockValue keyword_unlock_value = 14;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public KeywordUnlockValueOuterClass.KeywordUnlockValue getMutableKeywordUnlockValue() {
      clearACNDNONOJPJOtherKeywordUnlockValue();
      bitField0_ |= 0x00000040;
      return keywordUnlockValue;
    }

    /**
     * <code>optional .KeywordUnlockValue keyword_unlock_value = 14;</code>
     * @param value the keywordUnlockValue to set
     * @return this
     */
    public RogueGameInfo setKeywordUnlockValue(
        final KeywordUnlockValueOuterClass.KeywordUnlockValue value) {
      clearACNDNONOJPJOtherKeywordUnlockValue();
      bitField0_ |= 0x00000040;
      keywordUnlockValue.copyFrom(value);
      return this;
    }

    /**
     * <code>optional .RogueGameItemValue game_item_value = 15;</code>
     * @return whether the gameItemValue field is set
     */
    public boolean hasGameItemValue() {
      return (bitField0_ & 0x00000080) != 0;
    }

    /**
     * <code>optional .RogueGameItemValue game_item_value = 15;</code>
     * @return this
     */
    public RogueGameInfo clearGameItemValue() {
      bitField0_ &= ~0x00000080;
      gameItemValue.clear();
      return this;
    }

    /**
     * <code>optional .RogueGameItemValue game_item_value = 15;</code>
     *
     * This method returns the internal storage object without modifying any has state.
     * The returned object should not be modified and be treated as read-only.
     *
     * Use {@link #getMutableGameItemValue()} if you want to modify it.
     *
     * @return internal storage object for reading
     */
    public RogueGameItemValueOuterClass.RogueGameItemValue getGameItemValue() {
      return gameItemValue;
    }

    /**
     * <code>optional .RogueGameItemValue game_item_value = 15;</code>
     *
     * This method returns the internal storage object and sets the corresponding
     * has state. The returned object will become part of this message and its
     * contents may be modified as long as the has state is not cleared.
     *
     * @return internal storage object for modifications
     */
    public RogueGameItemValueOuterClass.RogueGameItemValue getMutableGameItemValue() {
      clearACNDNONOJPJOtherGameItemValue();
      bitField0_ |= 0x00000080;
      return gameItemValue;
    }

    /**
     * <code>optional .RogueGameItemValue game_item_value = 15;</code>
     * @param value the gameItemValue to set
     * @return this
     */
    public RogueGameInfo setGameItemValue(
        final RogueGameItemValueOuterClass.RogueGameItemValue value) {
      clearACNDNONOJPJOtherGameItemValue();
      bitField0_ |= 0x00000080;
      gameItemValue.copyFrom(value);
      return this;
    }

    @Override
    public RogueGameInfo copyFrom(final RogueGameInfo other) {
      cachedSize = other.cachedSize;
      if ((bitField0_ | other.bitField0_) != 0) {
        bitField0_ = other.bitField0_;
        rogueBuffInfo.copyFrom(other.rogueBuffInfo);
        rogueTournFormulaInfo.copyFrom(other.rogueTournFormulaInfo);
        gameMiracleInfo.copyFrom(other.gameMiracleInfo);
        rogueDifficultyInfo.copyFrom(other.rogueDifficultyInfo);
        rogueLineupInfo.copyFrom(other.rogueLineupInfo);
        rogueAeonInfo.copyFrom(other.rogueAeonInfo);
        keywordUnlockValue.copyFrom(other.keywordUnlockValue);
        gameItemValue.copyFrom(other.gameItemValue);
      }
      return this;
    }

    @Override
    public RogueGameInfo mergeFrom(final RogueGameInfo other) {
      if (other.isEmpty()) {
        return this;
      }
      cachedSize = -1;
      if (other.hasRogueBuffInfo()) {
        getMutableRogueBuffInfo().mergeFrom(other.rogueBuffInfo);
      }
      if (other.hasRogueTournFormulaInfo()) {
        getMutableRogueTournFormulaInfo().mergeFrom(other.rogueTournFormulaInfo);
      }
      if (other.hasGameMiracleInfo()) {
        getMutableGameMiracleInfo().mergeFrom(other.gameMiracleInfo);
      }
      if (other.hasRogueDifficultyInfo()) {
        getMutableRogueDifficultyInfo().mergeFrom(other.rogueDifficultyInfo);
      }
      if (other.hasRogueLineupInfo()) {
        getMutableRogueLineupInfo().mergeFrom(other.rogueLineupInfo);
      }
      if (other.hasRogueAeonInfo()) {
        getMutableRogueAeonInfo().mergeFrom(other.rogueAeonInfo);
      }
      if (other.hasKeywordUnlockValue()) {
        getMutableKeywordUnlockValue().mergeFrom(other.keywordUnlockValue);
      }
      if (other.hasGameItemValue()) {
        getMutableGameItemValue().mergeFrom(other.gameItemValue);
      }
      return this;
    }

    @Override
    public RogueGameInfo clear() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      rogueBuffInfo.clear();
      rogueTournFormulaInfo.clear();
      gameMiracleInfo.clear();
      rogueDifficultyInfo.clear();
      rogueLineupInfo.clear();
      rogueAeonInfo.clear();
      keywordUnlockValue.clear();
      gameItemValue.clear();
      return this;
    }

    @Override
    public RogueGameInfo clearQuick() {
      if (isEmpty()) {
        return this;
      }
      cachedSize = -1;
      bitField0_ = 0;
      rogueBuffInfo.clearQuick();
      rogueTournFormulaInfo.clearQuick();
      gameMiracleInfo.clearQuick();
      rogueDifficultyInfo.clearQuick();
      rogueLineupInfo.clearQuick();
      rogueAeonInfo.clearQuick();
      keywordUnlockValue.clearQuick();
      gameItemValue.clearQuick();
      return this;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (!(o instanceof RogueGameInfo)) {
        return false;
      }
      RogueGameInfo other = (RogueGameInfo) o;
      return bitField0_ == other.bitField0_
        && (!hasRogueBuffInfo() || rogueBuffInfo.equals(other.rogueBuffInfo))
        && (!hasRogueTournFormulaInfo() || rogueTournFormulaInfo.equals(other.rogueTournFormulaInfo))
        && (!hasGameMiracleInfo() || gameMiracleInfo.equals(other.gameMiracleInfo))
        && (!hasRogueDifficultyInfo() || rogueDifficultyInfo.equals(other.rogueDifficultyInfo))
        && (!hasRogueLineupInfo() || rogueLineupInfo.equals(other.rogueLineupInfo))
        && (!hasRogueAeonInfo() || rogueAeonInfo.equals(other.rogueAeonInfo))
        && (!hasKeywordUnlockValue() || keywordUnlockValue.equals(other.keywordUnlockValue))
        && (!hasGameItemValue() || gameItemValue.equals(other.gameItemValue));
    }

    @Override
    public void writeTo(final ProtoSink output) throws IOException {
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(rogueBuffInfo);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeRawByte((byte) 58);
        output.writeMessageNoTag(rogueTournFormulaInfo);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeRawByte((byte) 82);
        output.writeMessageNoTag(gameMiracleInfo);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeRawByte((byte) 90);
        output.writeMessageNoTag(rogueDifficultyInfo);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeRawByte((byte) 98);
        output.writeMessageNoTag(rogueLineupInfo);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeRawByte((byte) 106);
        output.writeMessageNoTag(rogueAeonInfo);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeRawByte((byte) 114);
        output.writeMessageNoTag(keywordUnlockValue);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeRawByte((byte) 122);
        output.writeMessageNoTag(gameItemValue);
      }
    }

    @Override
    protected int computeSerializedSize() {
      int size = 0;
      if ((bitField0_ & 0x00000001) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(rogueBuffInfo);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(rogueTournFormulaInfo);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(gameMiracleInfo);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(rogueDifficultyInfo);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(rogueLineupInfo);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(rogueAeonInfo);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(keywordUnlockValue);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        size += 1 + ProtoSink.computeMessageSizeNoTag(gameItemValue);
      }
      return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RogueGameInfo mergeFrom(final ProtoSource input) throws IOException {
      // Enabled Fall-Through Optimization (QuickBuffers)
      int tag = input.readTag();
      while (true) {
        switch (tag) {
          case 18: {
            // rogueBuffInfo
            clearACNDNONOJPJOtherRogueBuffInfo();
            input.readMessage(rogueBuffInfo);
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 58) {
              break;
            }
          }
          case 58: {
            // rogueTournFormulaInfo
            clearACNDNONOJPJOtherRogueTournFormulaInfo();
            input.readMessage(rogueTournFormulaInfo);
            bitField0_ |= 0x00000002;
            tag = input.readTag();
            if (tag != 82) {
              break;
            }
          }
          case 82: {
            // gameMiracleInfo
            clearACNDNONOJPJOtherGameMiracleInfo();
            input.readMessage(gameMiracleInfo);
            bitField0_ |= 0x00000004;
            tag = input.readTag();
            if (tag != 90) {
              break;
            }
          }
          case 90: {
            // rogueDifficultyInfo
            clearACNDNONOJPJOtherRogueDifficultyInfo();
            input.readMessage(rogueDifficultyInfo);
            bitField0_ |= 0x00000008;
            tag = input.readTag();
            if (tag != 98) {
              break;
            }
          }
          case 98: {
            // rogueLineupInfo
            clearACNDNONOJPJOtherRogueLineupInfo();
            input.readMessage(rogueLineupInfo);
            bitField0_ |= 0x00000010;
            tag = input.readTag();
            if (tag != 106) {
              break;
            }
          }
          case 106: {
            // rogueAeonInfo
            clearACNDNONOJPJOtherRogueAeonInfo();
            input.readMessage(rogueAeonInfo);
            bitField0_ |= 0x00000020;
            tag = input.readTag();
            if (tag != 114) {
              break;
            }
          }
          case 114: {
            // keywordUnlockValue
            clearACNDNONOJPJOtherKeywordUnlockValue();
            input.readMessage(keywordUnlockValue);
            bitField0_ |= 0x00000040;
            tag = input.readTag();
            if (tag != 122) {
              break;
            }
          }
          case 122: {
            // gameItemValue
            clearACNDNONOJPJOtherGameItemValue();
            input.readMessage(gameItemValue);
            bitField0_ |= 0x00000080;
            tag = input.readTag();
            if (tag != 0) {
              break;
            }
          }
          case 0: {
            return this;
          }
          default: {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
        }
      }
    }

    @Override
    public void writeTo(final JsonSink output) throws IOException {
      output.beginObject();
      if ((bitField0_ & 0x00000001) != 0) {
        output.writeMessage(FieldNames.rogueBuffInfo, rogueBuffInfo);
      }
      if ((bitField0_ & 0x00000002) != 0) {
        output.writeMessage(FieldNames.rogueTournFormulaInfo, rogueTournFormulaInfo);
      }
      if ((bitField0_ & 0x00000004) != 0) {
        output.writeMessage(FieldNames.gameMiracleInfo, gameMiracleInfo);
      }
      if ((bitField0_ & 0x00000008) != 0) {
        output.writeMessage(FieldNames.rogueDifficultyInfo, rogueDifficultyInfo);
      }
      if ((bitField0_ & 0x00000010) != 0) {
        output.writeMessage(FieldNames.rogueLineupInfo, rogueLineupInfo);
      }
      if ((bitField0_ & 0x00000020) != 0) {
        output.writeMessage(FieldNames.rogueAeonInfo, rogueAeonInfo);
      }
      if ((bitField0_ & 0x00000040) != 0) {
        output.writeMessage(FieldNames.keywordUnlockValue, keywordUnlockValue);
      }
      if ((bitField0_ & 0x00000080) != 0) {
        output.writeMessage(FieldNames.gameItemValue, gameItemValue);
      }
      output.endObject();
    }

    @Override
    public RogueGameInfo mergeFrom(final JsonSource input) throws IOException {
      if (!input.beginObject()) {
        return this;
      }
      while (!input.isAtEnd()) {
        switch (input.readFieldHash()) {
          case 1107898267:
          case -694847243: {
            if (input.isAtField(FieldNames.rogueBuffInfo)) {
              if (!input.trySkipNullValue()) {
                clearACNDNONOJPJOtherRogueBuffInfo();
                input.readMessage(rogueBuffInfo);
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -62180808:
          case -1311740171: {
            if (input.isAtField(FieldNames.rogueTournFormulaInfo)) {
              if (!input.trySkipNullValue()) {
                clearACNDNONOJPJOtherRogueTournFormulaInfo();
                input.readMessage(rogueTournFormulaInfo);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -471061139:
          case 1278717673: {
            if (input.isAtField(FieldNames.gameMiracleInfo)) {
              if (!input.trySkipNullValue()) {
                clearACNDNONOJPJOtherGameMiracleInfo();
                input.readMessage(gameMiracleInfo);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case 664895363:
          case -318397875: {
            if (input.isAtField(FieldNames.rogueDifficultyInfo)) {
              if (!input.trySkipNullValue()) {
                clearACNDNONOJPJOtherRogueDifficultyInfo();
                input.readMessage(rogueDifficultyInfo);
                bitField0_ |= 0x00000008;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -781427625:
          case -1245441415: {
            if (input.isAtField(FieldNames.rogueLineupInfo)) {
              if (!input.trySkipNullValue()) {
                clearACNDNONOJPJOtherRogueLineupInfo();
                input.readMessage(rogueLineupInfo);
                bitField0_ |= 0x00000010;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1685018549:
          case -1375922619: {
            if (input.isAtField(FieldNames.rogueAeonInfo)) {
              if (!input.trySkipNullValue()) {
                clearACNDNONOJPJOtherRogueAeonInfo();
                input.readMessage(rogueAeonInfo);
                bitField0_ |= 0x00000020;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1252091164:
          case -1271709876: {
            if (input.isAtField(FieldNames.keywordUnlockValue)) {
              if (!input.trySkipNullValue()) {
                clearACNDNONOJPJOtherKeywordUnlockValue();
                input.readMessage(keywordUnlockValue);
                bitField0_ |= 0x00000040;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          case -1632879028:
          case 534254514: {
            if (input.isAtField(FieldNames.gameItemValue)) {
              if (!input.trySkipNullValue()) {
                clearACNDNONOJPJOtherGameItemValue();
                input.readMessage(gameItemValue);
                bitField0_ |= 0x00000080;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
          default: {
            input.skipUnknownField();
            break;
          }
        }
      }
      input.endObject();
      return this;
    }

    @Override
    public RogueGameInfo clone() {
      return new RogueGameInfo().copyFrom(this);
    }

    @Override
    public boolean isEmpty() {
      return ((bitField0_) == 0);
    }

    public static RogueGameInfo parseFrom(final byte[] data) throws InvalidProtocolBufferException {
      return ProtoMessage.mergeFrom(new RogueGameInfo(), data).checkInitialized();
    }

    public static RogueGameInfo parseFrom(final ProtoSource input) throws IOException {
      return ProtoMessage.mergeFrom(new RogueGameInfo(), input).checkInitialized();
    }

    public static RogueGameInfo parseFrom(final JsonSource input) throws IOException {
      return ProtoMessage.mergeFrom(new RogueGameInfo(), input).checkInitialized();
    }

    /**
     * @return factory for creating RogueGameInfo messages
     */
    public static MessageFactory<RogueGameInfo> getFactory() {
      return RogueGameInfoFactory.INSTANCE;
    }

    private enum RogueGameInfoFactory implements MessageFactory<RogueGameInfo> {
      INSTANCE;

      @Override
      public RogueGameInfo create() {
        return RogueGameInfo.newInstance();
      }
    }

    /**
     * Contains name constants used for serializing JSON
     */
    static class FieldNames {
      static final FieldName rogueBuffInfo = FieldName.forField("rogueBuffInfo", "rogue_buff_info");

      static final FieldName rogueTournFormulaInfo = FieldName.forField("rogueTournFormulaInfo", "rogue_tourn_formula_info");

      static final FieldName gameMiracleInfo = FieldName.forField("gameMiracleInfo", "game_miracle_info");

      static final FieldName rogueDifficultyInfo = FieldName.forField("rogueDifficultyInfo", "rogue_difficulty_info");

      static final FieldName rogueLineupInfo = FieldName.forField("rogueLineupInfo", "rogue_lineup_info");

      static final FieldName rogueAeonInfo = FieldName.forField("rogueAeonInfo", "rogue_aeon_info");

      static final FieldName keywordUnlockValue = FieldName.forField("keywordUnlockValue", "keyword_unlock_value");

      static final FieldName gameItemValue = FieldName.forField("gameItemValue", "game_item_value");
    }
  }
}
